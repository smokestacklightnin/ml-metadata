{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ML Metadata","text":"<p>ML Metadata (MLMD) is a library for recording and retrieving metadata associated with ML developer and data scientist workflows. MLMD is an integral part of TensorFlow Extended (TFX), but is designed so that it can be used independently.</p> <p>Every run of a production ML pipeline generates metadata containing information about the various pipeline components, their executions (e.g. training runs), and resulting artifacts (e.g. trained models). In the event of unexpected pipeline behavior or errors, this metadata can be leveraged to analyze the lineage of pipeline components and debug issues. Think of this metadata as the equivalent of logging in software development.</p> <p>MLMD helps you understand and analyze all the interconnected parts of your ML pipeline instead of analyzing them in isolation and can help you answer questions about your ML pipeline such as:</p> <ul> <li>Which dataset did the model train on?</li> <li>What were the hyperparameters used to train the model?</li> <li>Which pipeline run created the model?</li> <li>Which training run led to this model?</li> <li>Which version of TensorFlow created this model?</li> <li>When was the failed model pushed?</li> </ul>"},{"location":"#metadata-store","title":"Metadata store","text":"<p>MLMD registers the following types of metadata in a database called the Metadata Store.</p> <ol> <li>Metadata about the artifacts generated through the components/steps of your     ML pipelines</li> <li>Metadata about the executions of these components/steps</li> <li>Metadata about pipelines and associated lineage information</li> </ol> <p>The Metadata Store provides APIs to record and retrieve metadata to and from the storage backend. The storage backend is pluggable and can be extended. MLMD provides reference implementations for SQLite (which supports in-memory and disk) and MySQL out of the box.</p> <p>This graphic shows a high-level overview of the various components that are part of MLMD.</p> <p></p>"},{"location":"#metadata-storage-backends-and-store-connection-configuration","title":"Metadata storage backends and store connection configuration","text":"<p>The <code>MetadataStore</code> object receives a connection configuration that corresponds to the storage backend used.</p> <ul> <li>Fake Database provides an in-memory DB (using SQLite) for fast     experimentation and local runs. The database is deleted when the store     object is destroyed.</li> </ul> <pre><code>from ml_metadata import metadata_store\nfrom ml_metadata.proto import metadata_store_pb2\n\nconnection_config = metadata_store_pb2.ConnectionConfig()\nconnection_config.fake_database.SetInParent() # Sets an empty fake database proto.\nstore = metadata_store.MetadataStore(connection_config)\n</code></pre> <ul> <li>SQLite reads and writes files from disk.</li> </ul> <pre><code>connection_config = metadata_store_pb2.ConnectionConfig()\nconnection_config.sqlite.filename_uri = '...'\nconnection_config.sqlite.connection_mode = 3 # READWRITE_OPENCREATE\nstore = metadata_store.MetadataStore(connection_config)\n</code></pre> <ul> <li>MySQL connects to a MySQL server.</li> </ul> <pre><code>connection_config = metadata_store_pb2.ConnectionConfig()\nconnection_config.mysql.host = '...'\nconnection_config.mysql.port = '...'\nconnection_config.mysql.database = '...'\nconnection_config.mysql.user = '...'\nconnection_config.mysql.password = '...'\nstore = metadata_store.MetadataStore(connection_config)\n</code></pre> <p>Similarly, when using a MySQL instance with Google CloudSQL (quickstart, connect-overview), one could also use SSL option if applicable.</p> <pre><code>connection_config.mysql.ssl_options.key = '...'\nconnection_config.mysql.ssl_options.cert = '...'\nconnection_config.mysql.ssl_options.ca = '...'\nconnection_config.mysql.ssl_options.capath = '...'\nconnection_config.mysql.ssl_options.cipher = '...'\nconnection_config.mysql.ssl_options.verify_server_cert = '...'\nstore = metadata_store.MetadataStore(connection_config)\n</code></pre> <ul> <li>PostgreSQL connects to a PostgreSQL server.</li> </ul> <pre><code>connection_config = metadata_store_pb2.ConnectionConfig()\nconnection_config.postgresql.host = '...'\nconnection_config.postgresql.port = '...'\nconnection_config.postgresql.user = '...'\nconnection_config.postgresql.password = '...'\nconnection_config.postgresql.dbname = '...'\nstore = metadata_store.MetadataStore(connection_config)\n</code></pre> <p>Similarly, when using a PostgreSQL instance with Google CloudSQL (quickstart, connect-overview), one could also use SSL option if applicable.</p> <pre><code>connection_config.postgresql.ssloption.sslmode = '...' # disable, allow, verify-ca, verify-full, etc.\nconnection_config.postgresql.ssloption.sslcert = '...'\nconnection_config.postgresql.ssloption.sslkey = '...'\nconnection_config.postgresql.ssloption.sslpassword = '...'\nconnection_config.postgresql.ssloption.sslrootcert = '...'\nstore = metadata_store.MetadataStore(connection_config)\n</code></pre>"},{"location":"#data-model","title":"Data model","text":"<p>The Metadata Store uses the following data model to record and retrieve metadata from the storage backend.</p> <ul> <li><code>ArtifactType</code> describes an artifact's type and its properties that are     stored in the metadata store. You can register these types on-the-fly with     the metadata store in code, or you can load them in the store from a     serialized format. Once you register a type, its definition is available     throughout the lifetime of the store.</li> <li>An <code>Artifact</code> describes a specific instance of an <code>ArtifactType</code>, and its     properties that are written to the metadata store.</li> <li>An <code>ExecutionType</code> describes a type of component or step in a workflow, and     its runtime parameters.</li> <li>An <code>Execution</code> is a record of a component run or a step in an ML workflow     and the runtime parameters. An execution can be thought of as an instance of     an <code>ExecutionType</code>. Executions are recorded when you run an ML pipeline or     step.</li> <li>An <code>Event</code> is a record of the relationship between artifacts and executions.     When an execution happens, events record every artifact that was used by the     execution, and every artifact that was produced. These records allow for     lineage tracking throughout a workflow. By looking at all events, MLMD knows     what executions happened and what artifacts were created as a result. MLMD     can then recurse back from any artifact to all of its upstream inputs.</li> <li>A <code>ContextType</code> describes a type of conceptual group of artifacts and     executions in a workflow, and its structural properties. For example:     projects, pipeline runs, experiments, owners etc.</li> <li>A <code>Context</code> is an instance of a <code>ContextType</code>. It captures the shared     information within the group. For example: project name, changelist commit     id, experiment annotations etc. It has a user-defined unique name within its     <code>ContextType</code>.</li> <li>An <code>Attribution</code> is a record of the relationship between artifacts and     contexts.</li> <li>An <code>Association</code> is a record of the relationship between executions and     contexts.</li> </ul>"},{"location":"#mlmd-functionality","title":"MLMD Functionality","text":"<p>Tracking the inputs and outputs of all components/steps in an ML workflow and their lineage allows ML platforms to enable several important features. The following list provides a non-exhaustive overview of some of the major benefits.</p> <ul> <li>List all Artifacts of a specific type. Example: all Models that have     been trained.</li> <li>Load two Artifacts of the same type for comparison. Example: compare     results from two experiments.</li> <li>Show a DAG of all related executions and their input and output artifacts     of a context. Example: visualize the workflow of an experiment for     debugging and discovery.</li> <li>Recurse back through all events to see how an artifact was created.     Examples: see what data went into a model; enforce data retention plans.</li> <li>Identify all artifacts that were created using a given artifact.     Examples: see all Models trained from a specific dataset; mark models based     upon bad data.</li> <li>Determine if an execution has been run on the same inputs before.     Example: determine whether a component/step has already completed the same     work and the previous output can just be reused.</li> <li>Record and query context of workflow runs. Examples: track the owner and     changelist used for a workflow run; group the lineage by experiments; manage     artifacts by projects.</li> <li>Declarative nodes filtering capabilities on properties and 1-hop     neighborhood nodes. Examples: look for artifacts of a type and under some     pipeline context; return typed artifacts where a given property\u2019s value is     within a range; find previous executions in a context with the same inputs.</li> </ul> <p>See the MLMD tutorial for an example that shows you how to use the MLMD API and the metadata store to retrieve lineage information.</p>"},{"location":"#integrate-ml-metadata-into-your-ml-workflows","title":"Integrate ML Metadata into your ML Workflows","text":"<p>If you are a platform developer interested in integrating MLMD into your system, use the example workflow below to use the low-level MLMD APIs to track the execution of a training task. You can also use higher-level Python APIs in notebook environments to record experiment metadata.</p> <p></p> <p>1) Register artifact types</p> <pre><code># Create ArtifactTypes, e.g., Data and Model\ndata_type = metadata_store_pb2.ArtifactType()\ndata_type.name = \"DataSet\"\ndata_type.properties[\"day\"] = metadata_store_pb2.INT\ndata_type.properties[\"split\"] = metadata_store_pb2.STRING\ndata_type_id = store.put_artifact_type(data_type)\n\nmodel_type = metadata_store_pb2.ArtifactType()\nmodel_type.name = \"SavedModel\"\nmodel_type.properties[\"version\"] = metadata_store_pb2.INT\nmodel_type.properties[\"name\"] = metadata_store_pb2.STRING\nmodel_type_id = store.put_artifact_type(model_type)\n\n# Query all registered Artifact types.\nartifact_types = store.get_artifact_types()\n</code></pre> <p>2) Register execution types for all steps in the ML workflow</p> <pre><code># Create an ExecutionType, e.g., Trainer\ntrainer_type = metadata_store_pb2.ExecutionType()\ntrainer_type.name = \"Trainer\"\ntrainer_type.properties[\"state\"] = metadata_store_pb2.STRING\ntrainer_type_id = store.put_execution_type(trainer_type)\n\n# Query a registered Execution type with the returned id\n[registered_type] = store.get_execution_types_by_id([trainer_type_id])\n</code></pre> <p>3) Create an artifact of DataSet ArtifactType</p> <pre><code># Create an input artifact of type DataSet\ndata_artifact = metadata_store_pb2.Artifact()\ndata_artifact.uri = 'path/to/data'\ndata_artifact.properties[\"day\"].int_value = 1\ndata_artifact.properties[\"split\"].string_value = 'train'\ndata_artifact.type_id = data_type_id\n[data_artifact_id] = store.put_artifacts([data_artifact])\n\n# Query all registered Artifacts\nartifacts = store.get_artifacts()\n\n# Plus, there are many ways to query the same Artifact\n[stored_data_artifact] = store.get_artifacts_by_id([data_artifact_id])\nartifacts_with_uri = store.get_artifacts_by_uri(data_artifact.uri)\nartifacts_with_conditions = store.get_artifacts(\n      list_options=mlmd.ListOptions(\n          filter_query='uri LIKE \"%/data\" AND properties.day.int_value &gt; 0'))\n</code></pre> <p>4) Create an execution of the Trainer run</p> <pre><code># Register the Execution of a Trainer run\ntrainer_run = metadata_store_pb2.Execution()\ntrainer_run.type_id = trainer_type_id\ntrainer_run.properties[\"state\"].string_value = \"RUNNING\"\n[run_id] = store.put_executions([trainer_run])\n\n# Query all registered Execution\nexecutions = store.get_executions_by_id([run_id])\n# Similarly, the same execution can be queried with conditions.\nexecutions_with_conditions = store.get_executions(\n    list_options = mlmd.ListOptions(\n        filter_query='type = \"Trainer\" AND properties.state.string_value IS NOT NULL'))\n</code></pre> <p>5) Define the input event and read data</p> <pre><code># Define the input event\ninput_event = metadata_store_pb2.Event()\ninput_event.artifact_id = data_artifact_id\ninput_event.execution_id = run_id\ninput_event.type = metadata_store_pb2.Event.DECLARED_INPUT\n\n# Record the input event in the metadata store\nstore.put_events([input_event])\n</code></pre> <p>6) Declare the output artifact</p> <pre><code># Declare the output artifact of type SavedModel\nmodel_artifact = metadata_store_pb2.Artifact()\nmodel_artifact.uri = 'path/to/model/file'\nmodel_artifact.properties[\"version\"].int_value = 1\nmodel_artifact.properties[\"name\"].string_value = 'MNIST-v1'\nmodel_artifact.type_id = model_type_id\n[model_artifact_id] = store.put_artifacts([model_artifact])\n</code></pre> <p>7) Record the output event</p> <pre><code># Declare the output event\noutput_event = metadata_store_pb2.Event()\noutput_event.artifact_id = model_artifact_id\noutput_event.execution_id = run_id\noutput_event.type = metadata_store_pb2.Event.DECLARED_OUTPUT\n\n# Submit output event to the Metadata Store\nstore.put_events([output_event])\n</code></pre> <p>8) Mark the execution as completed</p> <pre><code>trainer_run.id = run_id\ntrainer_run.properties[\"state\"].string_value = \"COMPLETED\"\nstore.put_executions([trainer_run])\n</code></pre> <p>9) Group artifacts and executions under a context using attributions and assertions artifacts</p> <pre><code># Create a ContextType, e.g., Experiment with a note property\nexperiment_type = metadata_store_pb2.ContextType()\nexperiment_type.name = \"Experiment\"\nexperiment_type.properties[\"note\"] = metadata_store_pb2.STRING\nexperiment_type_id = store.put_context_type(experiment_type)\n\n# Group the model and the trainer run to an experiment.\nmy_experiment = metadata_store_pb2.Context()\nmy_experiment.type_id = experiment_type_id\n# Give the experiment a name\nmy_experiment.name = \"exp1\"\nmy_experiment.properties[\"note\"].string_value = \"My first experiment.\"\n[experiment_id] = store.put_contexts([my_experiment])\n\nattribution = metadata_store_pb2.Attribution()\nattribution.artifact_id = model_artifact_id\nattribution.context_id = experiment_id\n\nassociation = metadata_store_pb2.Association()\nassociation.execution_id = run_id\nassociation.context_id = experiment_id\n\nstore.put_attributions_and_associations([attribution], [association])\n\n# Query the Artifacts and Executions that are linked to the Context.\nexperiment_artifacts = store.get_artifacts_by_context(experiment_id)\nexperiment_executions = store.get_executions_by_context(experiment_id)\n\n# You can also use neighborhood queries to fetch these artifacts and executions\n# with conditions.\nexperiment_artifacts_with_conditions = store.get_artifacts(\n    list_options = mlmd.ListOptions(\n        filter_query=('contexts_a.type = \"Experiment\" AND contexts_a.name = \"exp1\"')))\nexperiment_executions_with_conditions = store.get_executions(\n    list_options = mlmd.ListOptions(\n        filter_query=('contexts_a.id = {}'.format(experiment_id))))\n</code></pre>"},{"location":"#use-mlmd-with-a-remote-grpc-server","title":"Use MLMD with a remote gRPC server","text":"<p>You can use MLMD with remote gRPC servers as shown below:</p> <ul> <li>Start a server</li> </ul> <pre><code>bazel run -c opt --define grpc_no_ares=true  //ml_metadata/metadata_store:metadata_store_server\n</code></pre> <p>By default, the server uses a fake in-memory db per request and does not persist the metadata across calls. It can also be configured with a MLMD <code>MetadataStoreServerConfig</code> to use SQLite files or MySQL instances. The config can be stored in a text protobuf file and passed to the binary with <code>--metadata_store_server_config_file=path_to_the_config_file</code>.</p> <p>An example <code>MetadataStoreServerConfig</code> file in text protobuf format:</p> <pre><code>connection_config {\n  sqlite {\n    filename_uri: '/tmp/test_db'\n    connection_mode: READWRITE_OPENCREATE\n  }\n}\n</code></pre> <ul> <li>Create the client stub and use it in Python</li> </ul> <pre><code>from grpc import insecure_channel\nfrom ml_metadata.proto import metadata_store_pb2\nfrom ml_metadata.proto import metadata_store_service_pb2\nfrom ml_metadata.proto import metadata_store_service_pb2_grpc\n\nchannel = insecure_channel('localhost:8080')\nstub = metadata_store_service_pb2_grpc.MetadataStoreServiceStub(channel)\n</code></pre> <ul> <li>Use MLMD with RPC calls</li> </ul> <pre><code># Create ArtifactTypes, e.g., Data and Model\ndata_type = metadata_store_pb2.ArtifactType()\ndata_type.name = \"DataSet\"\ndata_type.properties[\"day\"] = metadata_store_pb2.INT\ndata_type.properties[\"split\"] = metadata_store_pb2.STRING\n\nrequest = metadata_store_service_pb2.PutArtifactTypeRequest()\nrequest.all_fields_match = True\nrequest.artifact_type.CopyFrom(data_type)\nstub.PutArtifactType(request)\n\nmodel_type = metadata_store_pb2.ArtifactType()\nmodel_type.name = \"SavedModel\"\nmodel_type.properties[\"version\"] = metadata_store_pb2.INT\nmodel_type.properties[\"name\"] = metadata_store_pb2.STRING\n\nrequest.artifact_type.CopyFrom(model_type)\nstub.PutArtifactType(request)\n</code></pre>"},{"location":"#upgrade-the-mlmd-library","title":"Upgrade the MLMD library","text":"<p>When using a new MLMD release or your own build with an existing MLMD database, there may be changes to the database schema. Unless a breaking change is explicitly mentioned in the release note, all MLMD database schema changes are transparent for the MLMD API users. If there is a breaking change notice, then old databases can still be upgraded to use the new MLMD library.</p> <p>When the MLMD library connects to the database, it compares the expected schema version of the MLMD library (<code>library_version</code>) with the schema version (<code>db_version</code>) recorded in the given database. By default, MLMD will check the compatibility and raise errors when the versions are incompatible.</p> <ul> <li>If <code>library_version</code> is compatible with <code>db_version</code>, nothing happens.</li> <li> <p>If <code>library_version</code> is newer than <code>db_version</code>, and auto-migration is not     enabled, then MLMD raises a failed precondition error with the following     message:</p> <pre><code>MLMD database version $db_version is older than library version\n$library_version. Schema migration is disabled. Please upgrade the\ndatabase then use the library version; or switch to a older library\nversion to use the current database.\n</code></pre> </li> <li> <p>If <code>library_version</code> is older than <code>db_version</code>, by default MLMD library     returns errors to prevent any data loss. In this case, you should upgrade     the library version before using that database.</p> </li> </ul>"},{"location":"#upgrade-the-database-schema","title":"Upgrade the database schema","text":"<p>MLMD provides utilities to upgrade the database version.</p> <p>For example, when connecting to a backend with a Python library:</p> <pre><code>connection_config = metadata_store_pb2.ConnectionConfig()\nconnection_config.sqlite.filename_uri = '...'\nstore = metadata_store.MetadataStore(connection_config,\n                                     enable_upgrade_migration=True)\n</code></pre> <p>Or when using gRPC server, set the MetadataStoreServerConfig as follows:</p> <pre><code>connection_config {\n    ...\n}\nmigration_options {\n    enable_upgrade_migration: true\n}\n</code></pre> <p>MLMD then evolves the database by executing a series of migration scripts. If the backend supports DDL queries within a transaction (e.g., SQLite), MLMD runs the steps together within a single transaction, and the transaction is rolled-back when an error occurs. The migration script is provided together with any schema-change commit and verified through testing.</p> <p>Note</p> <p>The migration DDLs in MySQL are not transactional. When using MySQL, there should only be a single connection with the upgrade migration enabled to use the old database. Take a backup of the database before upgrading to prevent potential data losses.</p>"},{"location":"#downgrade-the-database-schema","title":"Downgrade the database schema","text":"<p>A misconfiguration in the deployment of MLMD may cause an accidental upgrade, e.g., when you tries out a new version of the library and accidentally connect to the production instance of MLMD and upgrade the database. To recover from these situations, MLMD provides a downgrade feature. During connection, if the migration options specify the <code>downgrade_to_schema_version</code>, MLMD will run a downgrade transaction to revert the schema version and migrate the data, then terminate the connection. Once the downgrade is done, use the older version of the library to connect to the database.</p> <p>For example:</p> <pre><code>connection_config = metadata_store_pb2.ConnectionConfig()\nconnection_config.sqlite.filename_uri = '...'\nmetadata_store.downgrade_schema(connection_config,\n                                downgrade_to_schema_version = 0)\n</code></pre> <p>Note</p> <p>When downgrading, MLMD prevents data loss as much as possible. However, newer schema versions might be inherently more expressive and hence a downgrade can introduce data loss. When using backends that do not support DDL transactions (e.g., MySQL), the database should be backed up before downgrading and the downgrade script should be the only MLMD connection to the database.</p> <p>The list of <code>schema_version</code> used in MLMD releases are:</p> ml-metadata (MLMD) schema_version 1.16.0 10 1.15.0 10 1.14.0 10 1.13.1 10 1.13.0 10 1.12.0 10 1.11.0 10 1.10.0 8 1.9.0 8 1.8.0 8 1.7.0 8 1.6.0 7 1.5.0 7 1.4.0 7 1.3.0 7 1.2.0 7 1.1.0 7 1.0.0 6 0.30.0 6 0.29.0 6 0.28.0 6 0.27.0 6 0.26.0 6 0.25.1 6 0.24.0 5 0.23.0 5 0.22.1 5 0.21.2 4 0.15.2 4 0.14.0 4 0.13.2 0"},{"location":"#resources","title":"Resources","text":"<p>The MLMD library has a high-level API that you can readily use with your ML pipelines. See the MLMD API documentation for more details.</p> <p>Check out MLMD Declarative Nodes Filtering to learn how to use MLMD declarative nodes filtering capabilities on properties and 1-hop neighborhood nodes.</p> <p>Also check out the MLMD tutorial to learn how to use MLMD to trace the lineage of your pipeline components.</p>"},{"location":"api/mlmd/","title":"mlmd","text":"<p>Init module for ML Metadata.</p>"},{"location":"api/mlmd/#modules","title":"Modules","text":"<p><code>errors</code> module: Exception types for MLMD errors.</p> <p><code>proto</code> module: ML Metadata proto module.</p>"},{"location":"api/mlmd/#classes","title":"Classes","text":"<p><code>class ListOptions</code>: Defines the available options when listing nodes.</p> <p><code>class MetadataStore</code>: A store for the metadata.</p> <p><code>class OrderByField</code>: Defines the available fields to order results in ListOperations.</p>"},{"location":"api/mlmd/#functions","title":"Functions","text":"<p><code>downgrade_schema(...)</code>: Downgrades the db specified in the connection config to a schema version.</p>"},{"location":"api/mlmd/mlmd/","title":"mlmd","text":""},{"location":"api/mlmd/mlmd/#ml_metadata","title":"ml_metadata","text":"<p>Init module for ML Metadata.</p>"},{"location":"api/mlmd/mlmd/#ml_metadata-classes","title":"Classes","text":""},{"location":"api/mlmd/mlmd/#ml_metadata.ListOptions","title":"ListOptions","text":"<p>               Bases: <code>object</code></p> <p>Defines the available options when listing nodes.</p> ATTRIBUTE DESCRIPTION <code>limit</code> <p>The maximum size of the result. If a value is not specified then all artifacts are returned.</p> <p> TYPE: <code>Optional[int]</code> </p> <code>order_by</code> <p>The field to order the results. If the field is not provided, then the order is up to the database backend implementation.</p> <p> TYPE: <code>Optional[OrderByField]</code> </p> <code>is_asc</code> <p>Specifies <code>order_by</code> is ascending or descending. If <code>order_by</code> is not given, the field is ignored. If <code>order_by</code> is set, then by default ascending order is used for performance benefit.</p> <p> TYPE: <code>bool</code> </p> <code>filter_query</code> <p>An optional boolean expression in SQL syntax to specify conditions on node attributes and directly connected assets. See https://github.com/google/ml-metadata/blob/master/ml_metadata/proto/metadata_store.proto#L705-L783 for the query capabilities and syntax.</p> <p> TYPE: <code>Optional[str]</code> </p>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore","title":"MetadataStore","text":"<pre><code>MetadataStore(\n    config, enable_upgrade_migration: bool = False\n)\n</code></pre> <p>               Bases: <code>object</code></p> <p>A store for the metadata.</p> <p>Initialize the MetadataStore.</p> <p>MetadataStore can directly connect to either the metadata database or the MLMD MetadataStore gRPC server.</p> PARAMETER DESCRIPTION <code>config</code> <p><code>proto.ConnectionConfig</code> or <code>proto.MetadataStoreClientConfig</code>. Configuration to connect to the database or the metadata store server.</p> <p> </p> <code>enable_upgrade_migration</code> <p>if set to True, the library upgrades the db schema and migrates all data if it connects to an old version backend. It is ignored when using gRPC <code>proto.MetadataStoreClientConfig</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def __init__(self, config, enable_upgrade_migration: bool = False):\n  \"\"\"Initialize the MetadataStore.\n\n  MetadataStore can directly connect to either the metadata database or\n  the MLMD MetadataStore gRPC server.\n\n  Args:\n    config: `proto.ConnectionConfig` or `proto.MetadataStoreClientConfig`.\n      Configuration to connect to the database or the metadata store server.\n    enable_upgrade_migration: if set to True, the library upgrades the db\n      schema and migrates all data if it connects to an old version backend.\n      It is ignored when using gRPC `proto.MetadataStoreClientConfig`.\n  \"\"\"\n  self._config = config\n  self._max_num_retries = 5\n  self._service_client_wrapper = None\n  if isinstance(config, proto.ConnectionConfig):\n    self._using_db_connection = True\n    migration_options = metadata_store_pb2.MigrationOptions()\n    migration_options.enable_upgrade_migration = enable_upgrade_migration\n    self._metadata_store = metadata_store_serialized.CreateMetadataStore(\n        config.SerializeToString(), migration_options.SerializeToString())\n    logging.log(logging.INFO, 'MetadataStore with DB connection initialized')\n    logging.log(logging.DEBUG, 'ConnectionConfig: %s', config)\n    if config.HasField('retry_options'):\n      self._max_num_retries = config.retry_options.max_num_retries\n      logging.log(logging.INFO,\n                  'retry options is overwritten: max_num_retries = %d',\n                  self._max_num_retries)\n    return\n  if not isinstance(config, proto.MetadataStoreClientConfig):\n    raise ValueError('MetadataStore is expecting either '\n                     'proto.ConnectionConfig or '\n                     'proto.MetadataStoreClientConfig')\n  self._grpc_timeout_sec = None\n  self._using_db_connection = False\n  if enable_upgrade_migration:\n    raise ValueError('Upgrade migration is not allowed when using gRPC '\n                     'connection client. Upgrade needs to be performed on '\n                     'the server side.')\n  channel = self._get_channel(config)\n  self._metadata_store_stub = (\n      metadata_store_service_pb2_grpc.MetadataStoreServiceStub(channel))\n  logging.log(logging.INFO, 'MetadataStore with gRPC connection initialized')\n  logging.log(logging.DEBUG, 'ConnectionConfig: %s', config)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore-attributes","title":"Attributes","text":""},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.pipeline_asset","title":"pipeline_asset  <code>property</code>","text":"<pre><code>pipeline_asset: None\n</code></pre> <p>Returns None as the pipeline asset.</p>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore-functions","title":"Functions","text":""},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifact_by_type_and_name","title":"get_artifact_by_type_and_name","text":"<pre><code>get_artifact_by_type_and_name(\n    type_name: str,\n    artifact_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Optional[Artifact]\n</code></pre> <p>Get the artifact of the given type and name.</p> <p>The API fails if more than one artifact is found.</p> PARAMETER DESCRIPTION <code>type_name</code> <p>The artifact type name to look for.</p> <p> TYPE: <code>str</code> </p> <code>artifact_name</code> <p>The artifact name to look for.</p> <p> TYPE: <code>str</code> </p> <code>type_version</code> <p>An optional artifact type version. If not given, then only the type_name and artifact_name are used to look for the artifact with default version.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Optional[Artifact]</code> <p>The Artifact matching the type and name.</p> <code>Optional[Artifact]</code> <p>None if no matched Artifact was found.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifact_by_type_and_name(\n    self,\n    type_name: str,\n    artifact_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Optional[proto.Artifact]:\n  \"\"\"Get the artifact of the given type and name.\n\n  The API fails if more than one artifact is found.\n\n  Args:\n    type_name: The artifact type name to look for.\n    artifact_name: The artifact name to look for.\n    type_version: An optional artifact type version. If not given, then only\n      the type_name and artifact_name are used to look for the artifact with\n      default version.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    The Artifact matching the type and name.\n    None if no matched Artifact was found.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactByTypeAndNameRequest()\n  request.type_name = type_name\n  request.artifact_name = artifact_name\n  if type_version:\n    request.type_version = type_version\n  response = metadata_store_service_pb2.GetArtifactByTypeAndNameResponse()\n\n  self._call('GetArtifactByTypeAndName', request, response)\n  if not response.HasField('artifact'):\n    return None\n  return response.artifact\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifact_type","title":"get_artifact_type","text":"<pre><code>get_artifact_type(\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; ArtifactType\n</code></pre> <p>Gets an artifact type by name and version.</p> PARAMETER DESCRIPTION <code>type_name</code> <p>the type with that name.</p> <p> TYPE: <code>str</code> </p> <code>type_version</code> <p>an optional version of the type, if not given, then only the type_name is used to look for types with no versions.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ArtifactType</code> <p>The type with name type_name and version type version.</p> RAISES DESCRIPTION <code>NotFoundError</code> <p>if no type exists.</p> <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifact_type(\n    self,\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; proto.ArtifactType:\n  \"\"\"Gets an artifact type by name and version.\n\n  Args:\n    type_name: the type with that name.\n    type_version: an optional version of the type, if not given, then only the\n      type_name is used to look for types with no versions.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    The type with name type_name and version type version.\n\n  Raises:\n    errors.NotFoundError: if no type exists.\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactTypeRequest()\n  request.type_name = type_name\n  if type_version:\n    request.type_version = type_version\n  response = metadata_store_service_pb2.GetArtifactTypeResponse()\n\n  self._call('GetArtifactType', request, response)\n  return response.artifact_type\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifact_types","title":"get_artifact_types","text":"<pre><code>get_artifact_types(\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[ArtifactType]\n</code></pre> <p>Gets all artifact types.</p> PARAMETER DESCRIPTION <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[ArtifactType]</code> <p>A list of all known ArtifactTypes.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifact_types(\n    self, extra_options: Optional[ExtraOptions] = None\n) -&gt; List[proto.ArtifactType]:\n  \"\"\"Gets all artifact types.\n\n  Args:\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of all known ArtifactTypes.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactTypesRequest()\n  response = metadata_store_service_pb2.GetArtifactTypesResponse()\n\n  self._call('GetArtifactTypes', request, response)\n  return list(response.artifact_types)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifact_types_by_external_ids","title":"get_artifact_types_by_external_ids","text":"<pre><code>get_artifact_types_by_external_ids(\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[ArtifactType]\n</code></pre> <p>Gets all artifact types with matching external ids.</p> PARAMETER DESCRIPTION <code>external_ids</code> <p>A list of external_ids for retrieving the ArtifactTypes.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[ArtifactType]</code> <p>ArtifactTypes with matching external_ids.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifact_types_by_external_ids(\n    self,\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.ArtifactType]:\n  \"\"\"Gets all artifact types with matching external ids.\n\n  Args:\n    external_ids: A list of external_ids for retrieving the ArtifactTypes.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    ArtifactTypes with matching external_ids.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactTypesByExternalIdsRequest(\n      external_ids=external_ids)\n  response = (\n      metadata_store_service_pb2.GetArtifactTypesByExternalIdsResponse())\n\n  self._call('GetArtifactTypesByExternalIds', request, response)\n  return response.artifact_types[:]\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifact_types_by_id","title":"get_artifact_types_by_id","text":"<pre><code>get_artifact_types_by_id(\n    type_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[ArtifactType]\n</code></pre> <p>Gets artifact types by ID.</p> PARAMETER DESCRIPTION <code>type_ids</code> <p>a sequence of artifact type IDs.</p> <p> TYPE: <code>Iterable[int]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[ArtifactType]</code> <p>A list of artifact types.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifact_types_by_id(\n    self,\n    type_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.ArtifactType]:\n  \"\"\"Gets artifact types by ID.\n\n  Args:\n    type_ids: a sequence of artifact type IDs.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of artifact types.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactTypesByIDRequest()\n  response = metadata_store_service_pb2.GetArtifactTypesByIDResponse()\n  for x in type_ids:\n    request.type_ids.append(x)\n\n  self._call('GetArtifactTypesByID', request, response)\n  return list(response.artifact_types)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifacts","title":"get_artifacts","text":"<pre><code>get_artifacts(\n    list_options: Optional[ListOptions] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Artifact]\n</code></pre> <p>Gets artifacts.</p> PARAMETER DESCRIPTION <code>list_options</code> <p>A set of options to specify the conditions, limit the size and adjust order of the returned artifacts.</p> <p> TYPE: <code>Optional[ListOptions]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Artifact]</code> <p>A list of artifacts.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> <code>InvalidArgument</code> <p>if list_options is invalid.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifacts(\n    self,\n    list_options: Optional[ListOptions] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Artifact]:\n  \"\"\"Gets artifacts.\n\n  Args:\n    list_options: A set of options to specify the conditions, limit the size\n      and adjust order of the returned artifacts.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of artifacts.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n    errors.InvalidArgument: if list_options is invalid.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactsRequest()\n  return self._call_method_with_list_options('GetArtifacts', 'artifacts',\n                                             request, list_options)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifacts_and_types_by_artifact_ids","title":"get_artifacts_and_types_by_artifact_ids","text":"<pre><code>get_artifacts_and_types_by_artifact_ids(\n    artifact_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Tuple[List[Artifact], List[ArtifactType]]\n</code></pre> <p>Gets all artifacts with matching ids and populates types.</p> <p>The result is not index-aligned: if an id is not found, it is not returned.</p> PARAMETER DESCRIPTION <code>artifact_ids</code> <p>A list of artifact ids to retrieve.</p> <p> TYPE: <code>Iterable[int]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tuple[List[Artifact], List[ArtifactType]]</code> <p>Artifacts with matching ids and ArtifactTypes which can be matched by type_ids from Artifacts. Each ArtifactType contains id, name, properties and custom_properties fields.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifacts_and_types_by_artifact_ids(\n    self,\n    artifact_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Tuple[List[proto.Artifact], List[proto.ArtifactType]]:\n  \"\"\"Gets all artifacts with matching ids and populates types.\n\n  The result is not index-aligned: if an id is not found, it is not returned.\n\n  Args:\n    artifact_ids: A list of artifact ids to retrieve.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Artifacts with matching ids and ArtifactTypes which can be matched by\n      type_ids from Artifacts. Each ArtifactType contains id, name,\n      properties and custom_properties fields.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactsByIDRequest(\n      artifact_ids=artifact_ids, populate_artifact_types=True\n  )\n  response = metadata_store_service_pb2.GetArtifactsByIDResponse()\n\n  self._call('GetArtifactsByID', request, response)\n  return list(response.artifacts), list(response.artifact_types)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifacts_by_context","title":"get_artifacts_by_context","text":"<pre><code>get_artifacts_by_context(\n    context_id: int,\n    list_options: Optional[ListOptions] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Artifact]\n</code></pre> <p>Gets all direct artifacts that are attributed to the given context.</p> PARAMETER DESCRIPTION <code>context_id</code> <p>The id of the querying context</p> <p> TYPE: <code>int</code> </p> <code>list_options</code> <p>A set of options to specify the conditions, limit the size and adjust order of the returned executions.</p> <p> TYPE: <code>Optional[ListOptions]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Artifact]</code> <p>Artifacts attributing to the context.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifacts_by_context(\n    self,\n    context_id: int,\n    list_options: Optional[ListOptions] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Artifact]:\n  \"\"\"Gets all direct artifacts that are attributed to the given context.\n\n  Args:\n    context_id: The id of the querying context\n    list_options: A set of options to specify the conditions, limit the size\n      and adjust order of the returned executions.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Artifacts attributing to the context.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactsByContextRequest()\n  request.context_id = context_id\n  return self._call_method_with_list_options('GetArtifactsByContext',\n                                             'artifacts', request,\n                                             list_options)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifacts_by_external_ids","title":"get_artifacts_by_external_ids","text":"<pre><code>get_artifacts_by_external_ids(\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Artifact]\n</code></pre> <p>Gets all artifacts with matching external ids.</p> PARAMETER DESCRIPTION <code>external_ids</code> <p>A list of external_ids for retrieving the Artifacts.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Artifact]</code> <p>Artifacts with matching external_ids.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifacts_by_external_ids(\n    self,\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Artifact]:\n  \"\"\"Gets all artifacts with matching external ids.\n\n  Args:\n    external_ids: A list of external_ids for retrieving the Artifacts.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Artifacts with matching external_ids.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactsByExternalIdsRequest(\n      external_ids=external_ids)\n  response = metadata_store_service_pb2.GetArtifactsByExternalIdsResponse()\n\n  self._call('GetArtifactsByExternalIds', request, response)\n  return response.artifacts[:]\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifacts_by_id","title":"get_artifacts_by_id","text":"<pre><code>get_artifacts_by_id(\n    artifact_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Artifact]\n</code></pre> <p>Gets all artifacts with matching ids.</p> <p>The result is not index-aligned: if an id is not found, it is not returned.</p> PARAMETER DESCRIPTION <code>artifact_ids</code> <p>A list of artifact ids to retrieve.</p> <p> TYPE: <code>Iterable[int]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Artifact]</code> <p>Artifacts with matching ids.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifacts_by_id(\n    self,\n    artifact_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Artifact]:\n  \"\"\"Gets all artifacts with matching ids.\n\n  The result is not index-aligned: if an id is not found, it is not returned.\n\n  Args:\n    artifact_ids: A list of artifact ids to retrieve.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Artifacts with matching ids.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactsByIDRequest()\n  for x in artifact_ids:\n    request.artifact_ids.append(x)\n  response = metadata_store_service_pb2.GetArtifactsByIDResponse()\n\n  self._call('GetArtifactsByID', request, response)\n  return list(response.artifacts)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifacts_by_type","title":"get_artifacts_by_type","text":"<pre><code>get_artifacts_by_type(\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Artifact]\n</code></pre> <p>Gets all the artifacts of a given type.</p> PARAMETER DESCRIPTION <code>type_name</code> <p>The artifact type name to look for.</p> <p> TYPE: <code>str</code> </p> <code>type_version</code> <p>An optional artifact type version. If not given, then only the type_name are used to look for the artifacts with default version.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Artifact]</code> <p>Artifacts that matches the type.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifacts_by_type(\n    self,\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Artifact]:\n  \"\"\"Gets all the artifacts of a given type.\n\n  Args:\n    type_name: The artifact type name to look for.\n    type_version: An optional artifact type version. If not given, then only\n      the type_name are used to look for the artifacts with default version.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Artifacts that matches the type.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactsByTypeRequest()\n  request.type_name = type_name\n  if type_version:\n    request.type_version = type_version\n  response = metadata_store_service_pb2.GetArtifactsByTypeResponse()\n\n  self._call('GetArtifactsByType', request, response)\n  return list(response.artifacts)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_artifacts_by_uri","title":"get_artifacts_by_uri","text":"<pre><code>get_artifacts_by_uri(\n    uri: str, extra_options: Optional[ExtraOptions] = None\n) -&gt; List[Artifact]\n</code></pre> <p>Gets all the artifacts of a given uri.</p> PARAMETER DESCRIPTION <code>uri</code> <p>The artifact uri to look for.</p> <p> TYPE: <code>str</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Artifact]</code> <p>The Artifacts matching the uri.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_artifacts_by_uri(\n    self, uri: str, extra_options: Optional[ExtraOptions] = None\n) -&gt; List[proto.Artifact]:\n  \"\"\"Gets all the artifacts of a given uri.\n\n  Args:\n    uri: The artifact uri to look for.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    The Artifacts matching the uri.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetArtifactsByURIRequest()\n  request.uris.append(uri)\n  response = metadata_store_service_pb2.GetArtifactsByURIResponse()\n\n  self._call('GetArtifactsByURI', request, response)\n  return list(response.artifacts)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_children_contexts_by_context","title":"get_children_contexts_by_context","text":"<pre><code>get_children_contexts_by_context(\n    context_id: int,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Context]\n</code></pre> <p>Gets all children contexts of a context.</p> PARAMETER DESCRIPTION <code>context_id</code> <p>The id of the querying context.</p> <p> TYPE: <code>int</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Context]</code> <p>Children contexts of the querying context.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_children_contexts_by_context(\n    self, context_id: int, extra_options: Optional[ExtraOptions] = None\n) -&gt; List[proto.Context]:\n  \"\"\"Gets all children contexts of a context.\n\n  Args:\n    context_id: The id of the querying context.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Children contexts of the querying context.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetChildrenContextsByContextRequest()\n  request.context_id = context_id\n  response = metadata_store_service_pb2.GetChildrenContextsByContextResponse()\n  self._call('GetChildrenContextsByContext', request, response)\n  return list(response.contexts)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_context_by_type_and_name","title":"get_context_by_type_and_name","text":"<pre><code>get_context_by_type_and_name(\n    type_name: str,\n    context_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Optional[Context]\n</code></pre> <p>Get the context of the given type and context name.</p> <p>The API fails if more than one contexts are found.</p> PARAMETER DESCRIPTION <code>type_name</code> <p>The context type name to look for.</p> <p> TYPE: <code>str</code> </p> <code>context_name</code> <p>The context name to look for.</p> <p> TYPE: <code>str</code> </p> <code>type_version</code> <p>An optional context type version. If not given, then only the type_name and context_name are used to look for the context with default version.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Optional[Context]</code> <p>The Context matching the type and context name.</p> <code>Optional[Context]</code> <p>None if no matched Context found.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_context_by_type_and_name(\n    self,\n    type_name: str,\n    context_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Optional[proto.Context]:\n  \"\"\"Get the context of the given type and context name.\n\n  The API fails if more than one contexts are found.\n\n  Args:\n    type_name: The context type name to look for.\n    context_name: The context name to look for.\n    type_version: An optional context type version. If not given, then only\n      the type_name and context_name are used to look for the context with\n      default version.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    The Context matching the type and context name.\n    None if no matched Context found.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextByTypeAndNameRequest()\n  request.type_name = type_name\n  request.context_name = context_name\n  if type_version:\n    request.type_version = type_version\n  response = metadata_store_service_pb2.GetContextByTypeAndNameResponse()\n\n  self._call('GetContextByTypeAndName', request, response)\n  if not response.HasField('context'):\n    return None\n  return response.context\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_context_type","title":"get_context_type","text":"<pre><code>get_context_type(\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; ContextType\n</code></pre> <p>Gets a context type by name and version.</p> PARAMETER DESCRIPTION <code>type_name</code> <p>the type with that name.</p> <p> TYPE: <code>str</code> </p> <code>type_version</code> <p>an optional version of the type, if not given, then only the type_name is used to look for types with no versions.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ContextType</code> <p>The type with name type_name and version type_version.</p> RAISES DESCRIPTION <code>NotFoundError</code> <p>if no type exists.</p> <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_context_type(\n    self,\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; proto.ContextType:\n  \"\"\"Gets a context type by name and version.\n\n  Args:\n    type_name: the type with that name.\n    type_version: an optional version of the type, if not given, then only the\n      type_name is used to look for types with no versions.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    The type with name type_name and version type_version.\n\n  Raises:\n    errors.NotFoundError: if no type exists.\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextTypeRequest()\n  request.type_name = type_name\n  if type_version:\n    request.type_version = type_version\n  response = metadata_store_service_pb2.GetContextTypeResponse()\n\n  self._call('GetContextType', request, response)\n  return response.context_type\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_context_types","title":"get_context_types","text":"<pre><code>get_context_types(\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[ContextType]\n</code></pre> <p>Gets all context types.</p> PARAMETER DESCRIPTION <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[ContextType]</code> <p>A list of all known ContextTypes.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_context_types(\n    self, extra_options: Optional[ExtraOptions] = None\n) -&gt; List[proto.ContextType]:\n  \"\"\"Gets all context types.\n\n  Args:\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of all known ContextTypes.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextTypesRequest()\n  response = metadata_store_service_pb2.GetContextTypesResponse()\n\n  self._call('GetContextTypes', request, response)\n  return list(response.context_types)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_context_types_by_external_ids","title":"get_context_types_by_external_ids","text":"<pre><code>get_context_types_by_external_ids(\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[ContextType]\n</code></pre> <p>Gets all context types with matching external ids.</p> PARAMETER DESCRIPTION <code>external_ids</code> <p>A list of external_ids for retrieving the ContextTypes.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[ContextType]</code> <p>ContextTypes with matching external_ids.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_context_types_by_external_ids(\n    self,\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.ContextType]:\n  \"\"\"Gets all context types with matching external ids.\n\n  Args:\n    external_ids: A list of external_ids for retrieving the ContextTypes.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    ContextTypes with matching external_ids.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextTypesByExternalIdsRequest(\n      external_ids=external_ids)\n  response = metadata_store_service_pb2.GetContextTypesByExternalIdsResponse()\n\n  self._call('GetContextTypesByExternalIds', request, response)\n  return response.context_types[:]\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_context_types_by_id","title":"get_context_types_by_id","text":"<pre><code>get_context_types_by_id(\n    type_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[ContextType]\n</code></pre> <p>Gets context types by ID.</p> PARAMETER DESCRIPTION <code>type_ids</code> <p>a sequence of context type IDs.</p> <p> TYPE: <code>Iterable[int]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[ContextType]</code> <p>A list of context types.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_context_types_by_id(\n    self,\n    type_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.ContextType]:\n  \"\"\"Gets context types by ID.\n\n  Args:\n    type_ids: a sequence of context type IDs.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of context types.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextTypesByIDRequest()\n  response = metadata_store_service_pb2.GetContextTypesByIDResponse()\n  for x in type_ids:\n    request.type_ids.append(x)\n\n  self._call('GetContextTypesByID', request, response)\n  return list(response.context_types)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_contexts","title":"get_contexts","text":"<pre><code>get_contexts(\n    list_options: Optional[ListOptions] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Context]\n</code></pre> <p>Gets contexts.</p> PARAMETER DESCRIPTION <code>list_options</code> <p>A set of options to specify the conditions, limit the size and adjust order of the returned contexts.</p> <p> TYPE: <code>Optional[ListOptions]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Context]</code> <p>A list of contexts.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> <code>InvalidArgument</code> <p>if list_options is invalid.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_contexts(\n    self,\n    list_options: Optional[ListOptions] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Context]:\n  \"\"\"Gets contexts.\n\n  Args:\n    list_options: A set of options to specify the conditions, limit the size\n      and adjust order of the returned contexts.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of contexts.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n    errors.InvalidArgument: if list_options is invalid.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextsRequest()\n  return self._call_method_with_list_options('GetContexts', 'contexts',\n                                             request, list_options)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_contexts_by_artifact","title":"get_contexts_by_artifact","text":"<pre><code>get_contexts_by_artifact(\n    artifact_id: int,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Context]\n</code></pre> <p>Gets all context that an artifact is attributed to.</p> PARAMETER DESCRIPTION <code>artifact_id</code> <p>The id of the querying artifact</p> <p> TYPE: <code>int</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Context]</code> <p>Contexts that the artifact is attributed to.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_contexts_by_artifact(\n    self, artifact_id: int, extra_options: Optional[ExtraOptions] = None\n) -&gt; List[proto.Context]:\n  \"\"\"Gets all context that an artifact is attributed to.\n\n  Args:\n    artifact_id: The id of the querying artifact\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Contexts that the artifact is attributed to.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextsByArtifactRequest()\n  request.artifact_id = artifact_id\n  response = metadata_store_service_pb2.GetContextsByArtifactResponse()\n\n  self._call('GetContextsByArtifact', request, response)\n  return list(response.contexts)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_contexts_by_execution","title":"get_contexts_by_execution","text":"<pre><code>get_contexts_by_execution(\n    execution_id: int,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Context]\n</code></pre> <p>Gets all context that an execution is associated with.</p> PARAMETER DESCRIPTION <code>execution_id</code> <p>The id of the querying execution</p> <p> TYPE: <code>int</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Context]</code> <p>Contexts that the execution is associated with.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_contexts_by_execution(\n    self, execution_id: int, extra_options: Optional[ExtraOptions] = None\n) -&gt; List[proto.Context]:\n  \"\"\"Gets all context that an execution is associated with.\n\n  Args:\n    execution_id: The id of the querying execution\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Contexts that the execution is associated with.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextsByExecutionRequest()\n  request.execution_id = execution_id\n  response = metadata_store_service_pb2.GetContextsByExecutionResponse()\n\n  self._call('GetContextsByExecution', request, response)\n  return list(response.contexts)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_contexts_by_external_ids","title":"get_contexts_by_external_ids","text":"<pre><code>get_contexts_by_external_ids(\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Context]\n</code></pre> <p>Gets all contexts with matching external ids.</p> PARAMETER DESCRIPTION <code>external_ids</code> <p>A list of external_ids for retrieving the Contexts.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Context]</code> <p>Contexts with matching external_ids.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_contexts_by_external_ids(\n    self,\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Context]:\n  \"\"\"Gets all contexts with matching external ids.\n\n  Args:\n    external_ids: A list of external_ids for retrieving the Contexts.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Contexts with matching external_ids.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextsByExternalIdsRequest(\n      external_ids=external_ids)\n  response = metadata_store_service_pb2.GetContextsByExternalIdsResponse()\n\n  self._call('GetContextsByExternalIds', request, response)\n  return response.contexts[:]\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_contexts_by_id","title":"get_contexts_by_id","text":"<pre><code>get_contexts_by_id(\n    context_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Context]\n</code></pre> <p>Gets all contexts with matching ids.</p> <p>The result is not index-aligned: if an id is not found, it is not returned.</p> PARAMETER DESCRIPTION <code>context_ids</code> <p>A list of context ids to retrieve.</p> <p> TYPE: <code>Iterable[int]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Context]</code> <p>Contexts with matching ids.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_contexts_by_id(\n    self,\n    context_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Context]:\n  \"\"\"Gets all contexts with matching ids.\n\n  The result is not index-aligned: if an id is not found, it is not returned.\n\n  Args:\n    context_ids: A list of context ids to retrieve.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Contexts with matching ids.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextsByIDRequest()\n  for x in context_ids:\n    request.context_ids.append(x)\n  response = metadata_store_service_pb2.GetContextsByIDResponse()\n\n  self._call('GetContextsByID', request, response)\n  return list(response.contexts)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_contexts_by_type","title":"get_contexts_by_type","text":"<pre><code>get_contexts_by_type(\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Context]\n</code></pre> <p>Gets all the contexts of a given type.</p> PARAMETER DESCRIPTION <code>type_name</code> <p>The context type name to look for.</p> <p> TYPE: <code>str</code> </p> <code>type_version</code> <p>An optional context type version. If not given, then only the type_name are used to look for the contexts with default version.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Context]</code> <p>Contexts that matches the type.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_contexts_by_type(\n    self,\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Context]:\n  \"\"\"Gets all the contexts of a given type.\n\n  Args:\n    type_name: The context type name to look for.\n    type_version: An optional context type version. If not given, then only\n      the type_name are used to look for the contexts with default version.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Contexts that matches the type.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetContextsByTypeRequest()\n  request.type_name = type_name\n  if type_version:\n    request.type_version = type_version\n  response = metadata_store_service_pb2.GetContextsByTypeResponse()\n\n  self._call('GetContextsByType', request, response)\n  return list(response.contexts)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_events_by_artifact_ids","title":"get_events_by_artifact_ids","text":"<pre><code>get_events_by_artifact_ids(\n    artifact_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Event]\n</code></pre> <p>Gets all events with matching artifact ids.</p> PARAMETER DESCRIPTION <code>artifact_ids</code> <p>a list of artifact ids.</p> <p> TYPE: <code>Iterable[int]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Event]</code> <p>Events with the execution IDs given.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_events_by_artifact_ids(\n    self,\n    artifact_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Event]:\n  \"\"\"Gets all events with matching artifact ids.\n\n  Args:\n    artifact_ids: a list of artifact ids.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Events with the execution IDs given.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetEventsByArtifactIDsRequest()\n  for x in artifact_ids:\n    request.artifact_ids.append(x)\n  response = metadata_store_service_pb2.GetEventsByArtifactIDsResponse()\n\n  self._call('GetEventsByArtifactIDs', request, response)\n  return list(response.events)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_events_by_execution_ids","title":"get_events_by_execution_ids","text":"<pre><code>get_events_by_execution_ids(\n    execution_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Event]\n</code></pre> <p>Gets all events with matching execution ids.</p> PARAMETER DESCRIPTION <code>execution_ids</code> <p>a list of execution ids.</p> <p> TYPE: <code>Iterable[int]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Event]</code> <p>Events with the execution IDs given.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_events_by_execution_ids(\n    self,\n    execution_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Event]:\n  \"\"\"Gets all events with matching execution ids.\n\n  Args:\n    execution_ids: a list of execution ids.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Events with the execution IDs given.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetEventsByExecutionIDsRequest()\n  for x in execution_ids:\n    request.execution_ids.append(x)\n  response = metadata_store_service_pb2.GetEventsByExecutionIDsResponse()\n\n  self._call('GetEventsByExecutionIDs', request, response)\n  return list(response.events)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_execution_by_type_and_name","title":"get_execution_by_type_and_name","text":"<pre><code>get_execution_by_type_and_name(\n    type_name: str,\n    execution_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Optional[Execution]\n</code></pre> <p>Get the execution of the given type and name.</p> <p>The API fails if more than one execution is found.</p> PARAMETER DESCRIPTION <code>type_name</code> <p>The execution type name to look for.</p> <p> TYPE: <code>str</code> </p> <code>execution_name</code> <p>The execution name to look for.</p> <p> TYPE: <code>str</code> </p> <code>type_version</code> <p>An optional execution type version. If not given, then only the type_name and execution_name are used to look for the execution with default version.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Optional[Execution]</code> <p>The Execution matching the type and name.</p> <code>Optional[Execution]</code> <p>None if no matched Execution found.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_execution_by_type_and_name(\n    self,\n    type_name: str,\n    execution_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Optional[proto.Execution]:\n  \"\"\"Get the execution of the given type and name.\n\n  The API fails if more than one execution is found.\n\n  Args:\n    type_name: The execution type name to look for.\n    execution_name: The execution name to look for.\n    type_version: An optional execution type version. If not given, then only\n      the type_name and execution_name are used to look for the execution with\n      default version.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    The Execution matching the type and name.\n    None if no matched Execution found.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetExecutionByTypeAndNameRequest()\n  request.type_name = type_name\n  request.execution_name = execution_name\n  if type_version:\n    request.type_version = type_version\n  response = metadata_store_service_pb2.GetExecutionByTypeAndNameResponse()\n\n  self._call('GetExecutionByTypeAndName', request, response)\n  if not response.HasField('execution'):\n    return None\n  return response.execution\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_execution_type","title":"get_execution_type","text":"<pre><code>get_execution_type(\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; ExecutionType\n</code></pre> <p>Gets an execution type by name and version.</p> PARAMETER DESCRIPTION <code>type_name</code> <p>the type with that name.</p> <p> TYPE: <code>str</code> </p> <code>type_version</code> <p>an optional version of the type, if not given, then only the type_name is used to look for types with no versions.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ExecutionType</code> <p>The type with name type_name and version type_version.</p> RAISES DESCRIPTION <code>NotFoundError</code> <p>if no type exists.</p> <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_execution_type(\n    self,\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; proto.ExecutionType:\n  \"\"\"Gets an execution type by name and version.\n\n  Args:\n    type_name: the type with that name.\n    type_version: an optional version of the type, if not given, then only the\n      type_name is used to look for types with no versions.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    The type with name type_name and version type_version.\n\n  Raises:\n    errors.NotFoundError: if no type exists.\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetExecutionTypeRequest()\n  request.type_name = type_name\n  if type_version:\n    request.type_version = type_version\n  response = metadata_store_service_pb2.GetExecutionTypeResponse()\n\n  self._call('GetExecutionType', request, response)\n  return response.execution_type\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_execution_types","title":"get_execution_types","text":"<pre><code>get_execution_types(\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[ExecutionType]\n</code></pre> <p>Gets all execution types.</p> PARAMETER DESCRIPTION <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[ExecutionType]</code> <p>A list of all known ExecutionTypes.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_execution_types(\n    self, extra_options: Optional[ExtraOptions] = None\n) -&gt; List[proto.ExecutionType]:\n  \"\"\"Gets all execution types.\n\n  Args:\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of all known ExecutionTypes.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetExecutionTypesRequest()\n  response = metadata_store_service_pb2.GetExecutionTypesResponse()\n\n  self._call('GetExecutionTypes', request, response)\n  return list(response.execution_types)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_execution_types_by_external_ids","title":"get_execution_types_by_external_ids","text":"<pre><code>get_execution_types_by_external_ids(\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[ExecutionType]\n</code></pre> <p>Gets all execution types with matching external ids.</p> PARAMETER DESCRIPTION <code>external_ids</code> <p>A list of external_ids for retrieving the ExecutionTypes.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[ExecutionType]</code> <p>ExecutionTypes with matching external_ids.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_execution_types_by_external_ids(\n    self,\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.ExecutionType]:\n  \"\"\"Gets all execution types with matching external ids.\n\n  Args:\n    external_ids: A list of external_ids for retrieving the ExecutionTypes.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    ExecutionTypes with matching external_ids.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetExecutionTypesByExternalIdsRequest(\n      external_ids=external_ids)\n  response = (\n      metadata_store_service_pb2.GetExecutionTypesByExternalIdsResponse())\n\n  self._call('GetExecutionTypesByExternalIds', request, response)\n  return response.execution_types[:]\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_execution_types_by_id","title":"get_execution_types_by_id","text":"<pre><code>get_execution_types_by_id(\n    type_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[ExecutionType]\n</code></pre> <p>Gets execution types by ID.</p> PARAMETER DESCRIPTION <code>type_ids</code> <p>a sequence of execution type IDs.</p> <p> TYPE: <code>Iterable[int]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[ExecutionType]</code> <p>A list of execution types.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_execution_types_by_id(\n    self,\n    type_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.ExecutionType]:\n  \"\"\"Gets execution types by ID.\n\n  Args:\n    type_ids: a sequence of execution type IDs.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of execution types.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetExecutionTypesByIDRequest()\n  response = metadata_store_service_pb2.GetExecutionTypesByIDResponse()\n  for x in type_ids:\n    request.type_ids.append(x)\n\n  self._call('GetExecutionTypesByID', request, response)\n  return list(response.execution_types)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_executions","title":"get_executions","text":"<pre><code>get_executions(\n    list_options: Optional[ListOptions] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Execution]\n</code></pre> <p>Gets executions.</p> PARAMETER DESCRIPTION <code>list_options</code> <p>A set of options to specify the conditions, limit the size and adjust order of the returned executions.</p> <p> TYPE: <code>Optional[ListOptions]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Execution]</code> <p>A list of executions.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> <code>InvalidArgument</code> <p>if list_options is invalid.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_executions(\n    self,\n    list_options: Optional[ListOptions] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Execution]:\n  \"\"\"Gets executions.\n\n  Args:\n    list_options: A set of options to specify the conditions, limit the size\n      and adjust order of the returned executions.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of executions.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n    errors.InvalidArgument: if list_options is invalid.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetExecutionsRequest()\n  return self._call_method_with_list_options('GetExecutions', 'executions',\n                                             request, list_options)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_executions_by_context","title":"get_executions_by_context","text":"<pre><code>get_executions_by_context(\n    context_id: int,\n    list_options: Optional[ListOptions] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Execution]\n</code></pre> <p>Gets all direct executions that a context associates with.</p> PARAMETER DESCRIPTION <code>context_id</code> <p>The id of the querying context</p> <p> TYPE: <code>int</code> </p> <code>list_options</code> <p>A set of options to specify the conditions, limit the size and adjust order of the returned executions.</p> <p> TYPE: <code>Optional[ListOptions]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Execution]</code> <p>Executions associating with the context.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_executions_by_context(\n    self,\n    context_id: int,\n    list_options: Optional[ListOptions] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Execution]:\n  \"\"\"Gets all direct executions that a context associates with.\n\n  Args:\n    context_id: The id of the querying context\n    list_options: A set of options to specify the conditions, limit the size\n      and adjust order of the returned executions.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Executions associating with the context.\n  \"\"\"\n  del extra_options\n  if list_options is None:\n    # Default order is CREATE_TIME DESC.\n    list_options = ListOptions(\n        order_by=OrderByField.CREATE_TIME, is_asc=False)\n\n  request = metadata_store_service_pb2.GetExecutionsByContextRequest()\n  request.context_id = context_id\n  return self._call_method_with_list_options('GetExecutionsByContext',\n                                             'executions', request,\n                                             list_options)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_executions_by_external_ids","title":"get_executions_by_external_ids","text":"<pre><code>get_executions_by_external_ids(\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Execution]\n</code></pre> <p>Gets all executions with matching external ids.</p> PARAMETER DESCRIPTION <code>external_ids</code> <p>A list of external_ids for retrieving the Executions.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Execution]</code> <p>Executions with matching external_ids.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_executions_by_external_ids(\n    self,\n    external_ids: Iterable[str],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Execution]:\n  \"\"\"Gets all executions with matching external ids.\n\n  Args:\n    external_ids: A list of external_ids for retrieving the Executions.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Executions with matching external_ids.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetExecutionsByExternalIdsRequest(\n      external_ids=external_ids)\n  response = metadata_store_service_pb2.GetExecutionsByExternalIdsResponse()\n\n  self._call('GetExecutionsByExternalIds', request, response)\n  return response.executions[:]\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_executions_by_id","title":"get_executions_by_id","text":"<pre><code>get_executions_by_id(\n    execution_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Execution]\n</code></pre> <p>Gets all executions with matching ids.</p> <p>The result is not index-aligned: if an id is not found, it is not returned.</p> PARAMETER DESCRIPTION <code>execution_ids</code> <p>A list of execution ids to retrieve.</p> <p> TYPE: <code>Iterable[int]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Execution]</code> <p>Executions with matching ids.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_executions_by_id(\n    self,\n    execution_ids: Iterable[int],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Execution]:\n  \"\"\"Gets all executions with matching ids.\n\n  The result is not index-aligned: if an id is not found, it is not returned.\n\n  Args:\n    execution_ids: A list of execution ids to retrieve.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Executions with matching ids.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetExecutionsByIDRequest()\n  for x in execution_ids:\n    request.execution_ids.append(x)\n  response = metadata_store_service_pb2.GetExecutionsByIDResponse()\n\n  self._call('GetExecutionsByID', request, response)\n  return list(response.executions)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_executions_by_type","title":"get_executions_by_type","text":"<pre><code>get_executions_by_type(\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Execution]\n</code></pre> <p>Gets all the executions of a given type.</p> PARAMETER DESCRIPTION <code>type_name</code> <p>The execution type name to look for.</p> <p> TYPE: <code>str</code> </p> <code>type_version</code> <p>An optional execution type version. If not given, then only the type_name are used to look for the executions with default version.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Execution]</code> <p>Executions that matches the type.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_executions_by_type(\n    self,\n    type_name: str,\n    type_version: Optional[str] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[proto.Execution]:\n  \"\"\"Gets all the executions of a given type.\n\n  Args:\n    type_name: The execution type name to look for.\n    type_version: An optional execution type version. If not given, then only\n      the type_name are used to look for the executions with default version.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Executions that matches the type.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetExecutionsByTypeRequest()\n  request.type_name = type_name\n  response = metadata_store_service_pb2.GetExecutionsByTypeResponse()\n  if type_version:\n    request.type_version = type_version\n  self._call('GetExecutionsByType', request, response)\n  return list(response.executions)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_lineage_subgraph","title":"get_lineage_subgraph","text":"<pre><code>get_lineage_subgraph(\n    query_options: LineageSubgraphQueryOptions,\n    field_mask_paths: Optional[Sequence[str]] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; LineageGraph\n</code></pre> <p>Gets lineage graph including fields specified in a field mask.</p> PARAMETER DESCRIPTION <code>query_options</code> <p>metadata_store_pb2.LineageSubgraphQueryOptions object. It allows users to specify query options for lineage graph tracing from a list of interested nodes (limited to 100). Please refer to LineageSubgraphQueryOptions for more details.</p> <p> TYPE: <code>LineageSubgraphQueryOptions</code> </p> <code>field_mask_paths</code> <p>a list of user specified paths of fields that should be included in the returned lineage graph. If <code>field_mask_paths</code> is specified and non-empty:   1. If 'artifacts', 'executions', or 'contexts' is specified in   <code>read_mask</code>, the nodes with details will be included.   2. If 'artifact_types', 'execution_types', or 'context_types' is   specified in <code>read_mask</code>, all the node types with matched <code>type_id</code>   in nodes in the returned graph will be included.   3. If 'events', 'associations', or 'attributions' is specified in   <code>read_mask</code>, the corresponding edges will be included. If <code>field_mask_paths</code> is unspecified or is empty, it will return all the fields in the returned graph.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>LineageGraph</code> <p>metadata_store_pb2.LineageGraph object that contains the lineage graph.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_lineage_subgraph(\n    self,\n    query_options: metadata_store_pb2.LineageSubgraphQueryOptions,\n    field_mask_paths: Optional[Sequence[str]] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; metadata_store_pb2.LineageGraph:\n  \"\"\"Gets lineage graph including fields specified in a field mask.\n\n  Args:\n    query_options: metadata_store_pb2.LineageSubgraphQueryOptions object. It\n      allows users to specify query options for lineage graph tracing from a\n      list of interested nodes (limited to 100). Please refer to\n      LineageSubgraphQueryOptions for more details.\n    field_mask_paths: a list of user specified paths of fields that should be\n      included in the returned lineage graph.\n      If `field_mask_paths` is specified and non-empty:\n        1. If 'artifacts', 'executions', or 'contexts' is specified in\n        `read_mask`, the nodes with details will be included.\n        2. If 'artifact_types', 'execution_types', or 'context_types' is\n        specified in `read_mask`, all the node types with matched `type_id`\n        in nodes in the returned graph will be included.\n        3. If 'events', 'associations', or 'attributions' is specified in\n        `read_mask`, the corresponding edges will be included.\n      If `field_mask_paths` is unspecified or is empty, it will return all the\n      fields in the returned graph.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    metadata_store_pb2.LineageGraph object that contains the lineage graph.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetLineageSubgraphRequest(\n      lineage_subgraph_query_options=query_options\n  )\n  if not field_mask_paths:\n    field_mask_paths = [\n        field.name\n        for field in metadata_store_pb2.LineageGraph.DESCRIPTOR.fields\n    ]\n  # Do not get types from GetLineageSubgraph API, but send extra RPCs after\n  # retrieving node details.\n  request.read_mask.paths.extend(\n      path for path in field_mask_paths if not path.endswith('_types')\n  )\n  response = metadata_store_service_pb2.GetLineageSubgraphResponse()\n  self._call('GetLineageSubgraph', request, response)\n  skeleton = response.lineage_subgraph\n\n  lineage_subgraph = metadata_store_pb2.LineageGraph()\n  if (\n      _ARTIFACTS_FIELD_MASK_PATH in field_mask_paths\n      or _ARTIFACT_TYPES_FIELD_MASK_PATH in field_mask_paths\n  ):\n    artifacts, artifact_types = self.get_artifacts_and_types_by_artifact_ids(\n        artifact.id for artifact in skeleton.artifacts\n    )\n    if _ARTIFACTS_FIELD_MASK_PATH in field_mask_paths:\n      lineage_subgraph.artifacts.extend(artifacts)\n    if _ARTIFACT_TYPES_FIELD_MASK_PATH in field_mask_paths:\n      lineage_subgraph.artifact_types.extend(artifact_types)\n\n  # TODO(b/289277521): Use 1 rpc to get both executions and execution types.\n  if (\n      _EXECUTIONS_FIELD_MASK_PATH in field_mask_paths\n      or _EXECUTION_TYPES_FIELD_MASK_PATH in field_mask_paths\n  ):\n    executions = self.get_executions_by_id(\n        execution.id for execution in skeleton.executions\n    )\n    if _EXECUTIONS_FIELD_MASK_PATH in field_mask_paths:\n      lineage_subgraph.executions.extend(executions)\n    if _EXECUTION_TYPES_FIELD_MASK_PATH in field_mask_paths:\n      execution_types = self.get_execution_types_by_id(\n          set(execution.type_id for execution in executions)\n      )\n      lineage_subgraph.execution_types.extend(execution_types)\n\n  # TODO(b/289277521): Use 1 rpc to get both contexts and context types.\n  if (\n      _CONTEXTS_FIELD_MASK_PATH in field_mask_paths\n      or _CONTEXT_TYPES_FIELD_MASK_PATH in field_mask_paths\n  ):\n    contexts = self.get_contexts_by_id(\n        context.id for context in skeleton.contexts\n    )\n    if _CONTEXTS_FIELD_MASK_PATH in field_mask_paths:\n      lineage_subgraph.contexts.extend(contexts)\n    if _CONTEXT_TYPES_FIELD_MASK_PATH in field_mask_paths:\n      context_types = self.get_context_types_by_id(\n          set(context.type_id for context in contexts)\n      )\n      lineage_subgraph.context_types.extend(context_types)\n\n  if _EVENTS_FIELD_MASK_PATH in field_mask_paths:\n    lineage_subgraph.events.extend(skeleton.events)\n\n  if _ASSOCIATIONS_FIELD_MASK_PATH in field_mask_paths:\n    lineage_subgraph.associations.extend(skeleton.associations)\n\n  if _ATTRIBUTIONS_FIELD_MASK_PATH in field_mask_paths:\n    lineage_subgraph.attributions.extend(skeleton.attributions)\n\n  return lineage_subgraph\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.get_parent_contexts_by_context","title":"get_parent_contexts_by_context","text":"<pre><code>get_parent_contexts_by_context(\n    context_id: int,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[Context]\n</code></pre> <p>Gets all parent contexts of a context.</p> PARAMETER DESCRIPTION <code>context_id</code> <p>The id of the querying context.</p> <p> TYPE: <code>int</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Context]</code> <p>Parent contexts of the querying context.</p> RAISES DESCRIPTION <code>InternalError</code> <p>if query execution fails.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def get_parent_contexts_by_context(\n    self, context_id: int, extra_options: Optional[ExtraOptions] = None\n) -&gt; List[proto.Context]:\n  \"\"\"Gets all parent contexts of a context.\n\n  Args:\n    context_id: The id of the querying context.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    Parent contexts of the querying context.\n\n  Raises:\n    errors.InternalError: if query execution fails.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.GetParentContextsByContextRequest()\n  request.context_id = context_id\n  response = metadata_store_service_pb2.GetParentContextsByContextResponse()\n  self._call('GetParentContextsByContext', request, response)\n  return list(response.contexts)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_artifact_type","title":"put_artifact_type","text":"<pre><code>put_artifact_type(\n    artifact_type: ArtifactType,\n    can_add_fields: bool = False,\n    can_omit_fields: bool = False,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; int\n</code></pre> <p>Inserts or updates an artifact type.</p> <p>A type has a set of strong typed properties describing the schema of any stored instance associated with that type. A type is identified by a name and an optional version.</p> <p>Type Creation: If no type exists in the database with the given identifier (name, version), it creates a new type and returns the type_id.</p> <p>Type Evolution: If the request type with the same (name, version) already exists (let's call it stored_type), the method enforces the stored_type can be updated only when the request type is backward compatible for the already stored instances.</p> <p>Backwards compatibility is violated iff:</p> <ol> <li>there is a property where the request type and stored_type have      different value type (e.g., int vs. string)</li> <li><code>can_add_fields = false</code> and the request type has a new property that      is not stored.</li> <li><code>can_omit_fields = false</code> and stored_type has an existing property      that is not provided in the request type.</li> </ol> <p>If non-backward type change is required in the application, e.g., deprecate properties, re-purpose property name, change value types, a new type can be created with a different (name, version) identifier. Note the type version is optional, and a version value with empty string is treated as unset.</p> PARAMETER DESCRIPTION <code>artifact_type</code> <p>the request type to be inserted or updated.</p> <p> TYPE: <code>ArtifactType</code> </p> <code>can_add_fields</code> <p>when true, new properties can be added; when false, returns ALREADY_EXISTS if the request type has properties that are not in stored_type.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>can_omit_fields</code> <p>when true, stored properties can be omitted in the request type; when false, returns ALREADY_EXISTS if the stored_type has properties not in the request type.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>the type_id of the response.</p> RAISES DESCRIPTION <code>AlreadyExistsError</code> <p>If the type is not backward compatible.</p> <code>InvalidArgumentError</code> <p>If the request type has no name, or any property value type is unknown.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_artifact_type(\n    self,\n    artifact_type: proto.ArtifactType,\n    can_add_fields: bool = False,\n    can_omit_fields: bool = False,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; int:\n  \"\"\"Inserts or updates an artifact type.\n\n  A type has a set of strong typed properties describing the schema of any\n  stored instance associated with that type. A type is identified by a name\n  and an optional version.\n\n  Type Creation:\n  If no type exists in the database with the given identifier\n  (name, version), it creates a new type and returns the type_id.\n\n  Type Evolution:\n  If the request type with the same (name, version) already exists\n  (let's call it stored_type), the method enforces the stored_type can be\n  updated only when the request type is backward compatible for the already\n  stored instances.\n\n  Backwards compatibility is violated iff:\n\n    1. there is a property where the request type and stored_type have\n       different value type (e.g., int vs. string)\n    2. `can_add_fields = false` and the request type has a new property that\n       is not stored.\n    3. `can_omit_fields = false` and stored_type has an existing property\n       that is not provided in the request type.\n\n  If non-backward type change is required in the application, e.g.,\n  deprecate properties, re-purpose property name, change value types,\n  a new type can be created with a different (name, version) identifier.\n  Note the type version is optional, and a version value with empty string\n  is treated as unset.\n\n  Args:\n    artifact_type: the request type to be inserted or updated.\n    can_add_fields: when true, new properties can be added; when false,\n      returns ALREADY_EXISTS if the request type has properties that are not\n      in stored_type.\n    can_omit_fields: when true, stored properties can be omitted in the\n      request type; when false, returns ALREADY_EXISTS if the stored_type has\n      properties not in the request type.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    the type_id of the response.\n\n  Raises:\n    errors.AlreadyExistsError: If the type is not backward compatible.\n    errors.InvalidArgumentError: If the request type has no name, or any\n      property value type is unknown.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutArtifactTypeRequest(\n      can_add_fields=can_add_fields,\n      can_omit_fields=can_omit_fields,\n      artifact_type=artifact_type)\n  response = metadata_store_service_pb2.PutArtifactTypeResponse()\n  self._call('PutArtifactType', request, response)\n  return response.type_id\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_artifacts","title":"put_artifacts","text":"<pre><code>put_artifacts(\n    artifacts: Sequence[Artifact],\n    field_mask_paths: Optional[Sequence[str]] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[int]\n</code></pre> <p>Inserts or updates artifacts in the database.</p> <p>If an artifact id is specified for an artifact, it is an update. If an artifact id is unspecified, it will insert a new artifact. For new artifacts, type must be specified. For old artifacts, type must be unchanged or unspecified. When the name of an artifact is given, it should be unique among artifacts of the same ArtifactType.</p> <p>It is not guaranteed that the created or updated artifacts will share the same <code>create_time_since_epoch</code> or <code>last_update_time_since_epoch</code> timestamps.</p> <p>If <code>field_mask_paths</code> is specified and non-empty:   1. while updating an existing artifact, it only updates fields specified      in <code>field_mask_paths</code>.   2. while inserting a new artifact, <code>field_mask_paths</code> will be ignored.   3. otherwise, <code>field_mask_paths</code> will be applied to all <code>artifacts</code>. If <code>field_mask_paths</code> is unspecified or is empty, it updates the artifact as a whole.</p> PARAMETER DESCRIPTION <code>artifacts</code> <p>A list of artifacts to insert or update.</p> <p> TYPE: <code>Sequence[Artifact]</code> </p> <code>field_mask_paths</code> <p>A list of field mask paths for masked update.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[int]</code> <p>A list of artifact ids index-aligned with the input.</p> RAISES DESCRIPTION <code>AlreadyExistsError</code> <p>If artifact's name is specified and it is already used by stored artifacts of that ArtifactType.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_artifacts(\n    self,\n    artifacts: Sequence[proto.Artifact],\n    field_mask_paths: Optional[Sequence[str]] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[int]:\n  \"\"\"Inserts or updates artifacts in the database.\n\n  If an artifact id is specified for an artifact, it is an update.\n  If an artifact id is unspecified, it will insert a new artifact.\n  For new artifacts, type must be specified.\n  For old artifacts, type must be unchanged or unspecified.\n  When the name of an artifact is given, it should be unique among artifacts\n  of the same ArtifactType.\n\n  It is not guaranteed that the created or updated artifacts will share the\n  same `create_time_since_epoch` or `last_update_time_since_epoch` timestamps.\n\n  If `field_mask_paths` is specified and non-empty:\n    1. while updating an existing artifact, it only updates fields specified\n       in `field_mask_paths`.\n    2. while inserting a new artifact, `field_mask_paths` will be ignored.\n    3. otherwise, `field_mask_paths` will be applied to all `artifacts`.\n  If `field_mask_paths` is unspecified or is empty, it updates the artifact\n  as a whole.\n\n  Args:\n    artifacts: A list of artifacts to insert or update.\n    field_mask_paths: A list of field mask paths for masked update.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of artifact ids index-aligned with the input.\n\n  Raises:\n    errors.AlreadyExistsError: If artifact's name is specified and it is\n      already used by stored artifacts of that ArtifactType.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutArtifactsRequest()\n  for x in artifacts:\n    request.artifacts.add().CopyFrom(x)\n\n  if field_mask_paths:\n    for path in field_mask_paths:\n      request.update_mask.paths.append(path)\n  response = metadata_store_service_pb2.PutArtifactsResponse()\n\n  self._call('PutArtifacts', request, response)\n  return list(response.artifact_ids)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_attributions_and_associations","title":"put_attributions_and_associations","text":"<pre><code>put_attributions_and_associations(\n    attributions: Sequence[Attribution],\n    associations: Sequence[Association],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; None\n</code></pre> <p>Inserts attribution and association relationships in the database.</p> <p>The context_id, artifact_id, and execution_id must already exist. If the relationship exists, this call does nothing. Once added, the relationships cannot be modified.</p> PARAMETER DESCRIPTION <code>attributions</code> <p>A list of attributions to insert.</p> <p> TYPE: <code>Sequence[Attribution]</code> </p> <code>associations</code> <p>A list of associations to insert.</p> <p> TYPE: <code>Sequence[Association]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_attributions_and_associations(\n    self,\n    attributions: Sequence[proto.Attribution],\n    associations: Sequence[proto.Association],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; None:\n  \"\"\"Inserts attribution and association relationships in the database.\n\n  The context_id, artifact_id, and execution_id must already exist.\n  If the relationship exists, this call does nothing. Once added, the\n  relationships cannot be modified.\n\n  Args:\n    attributions: A list of attributions to insert.\n    associations: A list of associations to insert.\n    extra_options: ExtraOptions instance.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutAttributionsAndAssociationsRequest()\n  for x in attributions:\n    request.attributions.add().CopyFrom(x)\n  for x in associations:\n    request.associations.add().CopyFrom(x)\n  response = metadata_store_service_pb2.PutAttributionsAndAssociationsResponse(\n  )\n  self._call('PutAttributionsAndAssociations', request, response)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_context_type","title":"put_context_type","text":"<pre><code>put_context_type(\n    context_type: ContextType,\n    can_add_fields: bool = False,\n    can_omit_fields: bool = False,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; int\n</code></pre> <p>Inserts or updates a context type.</p> <p>A type has a set of strong typed properties describing the schema of any stored instance associated with that type. A type is identified by a name and an optional version.</p> <p>Type Creation: If no type exists in the database with the given identifier (name, version), it creates a new type and returns the type_id.</p> <p>Type Evolution: If the request type with the same (name, version) already exists (let's call it stored_type), the method enforces the stored_type can be updated only when the request type is backward compatible for the already stored instances.</p> <p>Backwards compatibility is violated iff:</p> <ol> <li>there is a property where the request type and stored_type have      different value type (e.g., int vs. string)</li> <li><code>can_add_fields = false</code> and the request type has a new property that      is not stored.</li> <li><code>can_omit_fields = false</code> and stored_type has an existing property      that is not provided in the request type.</li> </ol> <p>If non-backward type change is required in the application, e.g., deprecate properties, re-purpose property name, change value types, a new type can be created with a different (name, version) identifier. Note the type version is optional, and a version value with empty string is treated as unset.</p> PARAMETER DESCRIPTION <code>context_type</code> <p>the request type to be inserted or updated.</p> <p> TYPE: <code>ContextType</code> </p> <code>can_add_fields</code> <p>when true, new properties can be added; when false, returns ALREADY_EXISTS if the request type has properties that are not in stored_type.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>can_omit_fields</code> <p>when true, stored properties can be omitted in the request type; when false, returns ALREADY_EXISTS if the stored_type has properties not in the request type.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>the type_id of the response.</p> RAISES DESCRIPTION <code>AlreadyExistsError</code> <p>If the type is not backward compatible.</p> <code>InvalidArgumentError</code> <p>If the request type has no name, or any property value type is unknown.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_context_type(\n    self,\n    context_type: proto.ContextType,\n    can_add_fields: bool = False,\n    can_omit_fields: bool = False,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; int:\n  \"\"\"Inserts or updates a context type.\n\n  A type has a set of strong typed properties describing the schema of any\n  stored instance associated with that type. A type is identified by a name\n  and an optional version.\n\n  Type Creation:\n  If no type exists in the database with the given identifier\n  (name, version), it creates a new type and returns the type_id.\n\n  Type Evolution:\n  If the request type with the same (name, version) already exists\n  (let's call it stored_type), the method enforces the stored_type can be\n  updated only when the request type is backward compatible for the already\n  stored instances.\n\n  Backwards compatibility is violated iff:\n\n    1. there is a property where the request type and stored_type have\n       different value type (e.g., int vs. string)\n    2. `can_add_fields = false` and the request type has a new property that\n       is not stored.\n    3. `can_omit_fields = false` and stored_type has an existing property\n       that is not provided in the request type.\n\n  If non-backward type change is required in the application, e.g.,\n  deprecate properties, re-purpose property name, change value types,\n  a new type can be created with a different (name, version) identifier.\n  Note the type version is optional, and a version value with empty string\n  is treated as unset.\n\n  Args:\n    context_type: the request type to be inserted or updated.\n    can_add_fields: when true, new properties can be added; when false,\n      returns ALREADY_EXISTS if the request type has properties that are not\n      in stored_type.\n    can_omit_fields: when true, stored properties can be omitted in the\n      request type; when false, returns ALREADY_EXISTS if the stored_type has\n      properties not in the request type.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    the type_id of the response.\n\n  Raises:\n    errors.AlreadyExistsError: If the type is not backward compatible.\n    errors.InvalidArgumentError: If the request type has no name, or any\n      property value type is unknown.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutContextTypeRequest(\n      can_add_fields=can_add_fields,\n      can_omit_fields=can_omit_fields,\n      context_type=context_type)\n  response = metadata_store_service_pb2.PutContextTypeResponse()\n  self._call('PutContextType', request, response)\n  return response.type_id\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_contexts","title":"put_contexts","text":"<pre><code>put_contexts(\n    contexts: Sequence[Context],\n    field_mask_paths: Optional[Sequence[str]] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[int]\n</code></pre> <p>Inserts or updates contexts in the database.</p> <p>If an context id is specified for an context, it is an update. If an context id is unspecified, it will insert a new context. For new contexts, type must be specified. For old contexts, type must be unchanged or unspecified. The name of a context cannot be empty, and it should be unique among contexts of the same ContextType.</p> <p>It is not guaranteed that the created or updated contexts will share the same <code>create_time_since_epoch</code> or <code>last_update_time_since_epoch</code> timestamps.</p> <p>If <code>field_mask_paths</code> is specified and non-empty:   1. while updating an existing context, it only updates fields specified      in <code>field_mask_paths</code>.   2. while inserting a new context, <code>field_mask_paths</code> will be ignored.   3. otherwise, <code>field_mask_paths</code> will be applied to all <code>contexts</code>. If <code>field_mask_paths</code> is unspecified or is empty, it updates the context as a whole.</p> PARAMETER DESCRIPTION <code>contexts</code> <p>A list of contexts to insert or update.</p> <p> TYPE: <code>Sequence[Context]</code> </p> <code>field_mask_paths</code> <p>A list of field mask paths for masked update.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[int]</code> <p>A list of context ids index-aligned with the input.</p> RAISES DESCRIPTION <code>InvalidArgumentError</code> <p>If name of the new contexts are empty.</p> <code>AlreadyExistsError</code> <p>If name of the new contexts already used by stored contexts of that ContextType.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_contexts(\n    self,\n    contexts: Sequence[proto.Context],\n    field_mask_paths: Optional[Sequence[str]] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[int]:\n  \"\"\"Inserts or updates contexts in the database.\n\n  If an context id is specified for an context, it is an update.\n  If an context id is unspecified, it will insert a new context.\n  For new contexts, type must be specified.\n  For old contexts, type must be unchanged or unspecified.\n  The name of a context cannot be empty, and it should be unique among\n  contexts of the same ContextType.\n\n  It is not guaranteed that the created or updated contexts will share the\n  same `create_time_since_epoch` or `last_update_time_since_epoch` timestamps.\n\n  If `field_mask_paths` is specified and non-empty:\n    1. while updating an existing context, it only updates fields specified\n       in `field_mask_paths`.\n    2. while inserting a new context, `field_mask_paths` will be ignored.\n    3. otherwise, `field_mask_paths` will be applied to all `contexts`.\n  If `field_mask_paths` is unspecified or is empty, it updates the context\n  as a whole.\n\n  Args:\n    contexts: A list of contexts to insert or update.\n    field_mask_paths: A list of field mask paths for masked update.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of context ids index-aligned with the input.\n\n  Raises:\n    errors.InvalidArgumentError: If name of the new contexts are empty.\n    errors.AlreadyExistsError: If name of the new contexts already used by\n      stored contexts of that ContextType.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutContextsRequest()\n  for x in contexts:\n    request.contexts.add().CopyFrom(x)\n\n  if field_mask_paths:\n    for path in field_mask_paths:\n      request.update_mask.paths.append(path)\n  response = metadata_store_service_pb2.PutContextsResponse()\n\n  self._call('PutContexts', request, response)\n  return list(response.context_ids)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_events","title":"put_events","text":"<pre><code>put_events(\n    events: Sequence[Event],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; None\n</code></pre> <p>Inserts events in the database.</p> <p>The execution_id and artifact_id must already exist. Once created, events cannot be modified.</p> <p>It is not guaranteed that the created or updated events will share the same <code>milliseconds_since_epoch</code> timestamps.</p> PARAMETER DESCRIPTION <code>events</code> <p>A list of events to insert.</p> <p> TYPE: <code>Sequence[Event]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_events(\n    self,\n    events: Sequence[proto.Event],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; None:\n  \"\"\"Inserts events in the database.\n\n  The execution_id and artifact_id must already exist.\n  Once created, events cannot be modified.\n\n  It is not guaranteed that the created or updated events will share the\n  same `milliseconds_since_epoch` timestamps.\n\n  Args:\n    events: A list of events to insert.\n    extra_options: ExtraOptions instance.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutEventsRequest()\n  for x in events:\n    request.events.add().CopyFrom(x)\n  response = metadata_store_service_pb2.PutEventsResponse()\n\n  self._call('PutEvents', request, response)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_execution","title":"put_execution","text":"<pre><code>put_execution(\n    execution: Execution,\n    artifact_and_events: Sequence[\n        Tuple[Artifact, Optional[Event]]\n    ],\n    contexts: Optional[Sequence[Context]],\n    reuse_context_if_already_exist: bool = False,\n    reuse_artifact_if_already_exist_by_external_id: bool = False,\n    force_reuse_context: bool = False,\n    force_update_time: bool = False,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Tuple[int, List[int], List[int]]\n</code></pre> <p>Inserts or updates an Execution with artifacts, events and contexts.</p> <p>In contrast with other put methods, the method update an execution atomically with its input/output artifacts and events and adds attributions and associations to related contexts.</p> <p>If an execution_id, artifact_id or context_id is specified, it is an update, otherwise it does an insertion.</p> <p>It is not guaranteed that the created or updated executions, artifacts, contexts and events will share the same <code>create_time_since_epoch</code>, <code>last_update_time_since_epoch</code>, or <code>milliseconds_since_epoch</code> timestamps.</p> PARAMETER DESCRIPTION <code>execution</code> <p>The execution to be created or updated.</p> <p> TYPE: <code>Execution</code> </p> <code>artifact_and_events</code> <p>a pair of Artifact and Event that the execution uses or generates. The event's execution id or artifact id can be empty, as the artifact or execution may not be stored beforehand. If given, the ids must match with the paired Artifact and the input execution.</p> <p> TYPE: <code>Sequence[Tuple[Artifact, Optional[Event]]]</code> </p> <code>contexts</code> <p>The Contexts that the execution should be associated with and the artifacts should be attributed to.</p> <p> TYPE: <code>Optional[Sequence[Context]]</code> </p> <code>reuse_context_if_already_exist</code> <p>When there's a race to publish executions with a new context (no id) with the same context.name, by default there will be one writer succeeds and the rest of the writers fail with AlreadyExists errors. If set is to True, failed writers will reuse the stored context.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reuse_artifact_if_already_exist_by_external_id</code> <p>When there's a race to publish executions with a new artifact with the same artifact.external_id, by default there'll be one writer succeeds and the rest of the writers returning AlreadyExists errors. If set to true and an Artifact has non-empty external_id, the API will reuse the stored artifact in the transaction and perform an update. Otherwise, it will fall back to relying on <code>id</code> field to decide if it's update (if <code>id</code> exists) or insert (if <code>id</code> is empty).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_reuse_context</code> <p>If True, for contexts with a context.id, the stored context will NOT be updated. For such contexts,  we will only look at the context.id to associate the context with the execution.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_update_time</code> <p>If it is true, <code>last_update_time_since_epoch</code> is updated even if input execution is the same as stored execution.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tuple[int, List[int], List[int]]</code> <p>the execution id, the list of artifact's id, and the list of context's id.</p> RAISES DESCRIPTION <code>InvalidArgumentError</code> <p>If the id of the input nodes do not align with the store. Please refer to InvalidArgument errors in other put methods.</p> <code>AlreadyExistsError</code> <p>If the new nodes to be created is already exists. Please refer to AlreadyExists errors in other put methods.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_execution(\n    self,\n    execution: proto.Execution,\n    artifact_and_events: Sequence[\n        Tuple[proto.Artifact, Optional[proto.Event]]\n    ],\n    contexts: Optional[Sequence[proto.Context]],\n    reuse_context_if_already_exist: bool = False,\n    reuse_artifact_if_already_exist_by_external_id: bool = False,\n    force_reuse_context: bool = False,\n    force_update_time: bool = False,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Tuple[int, List[int], List[int]]:\n  \"\"\"Inserts or updates an Execution with artifacts, events and contexts.\n\n  In contrast with other put methods, the method update an\n  execution atomically with its input/output artifacts and events and adds\n  attributions and associations to related contexts.\n\n  If an execution_id, artifact_id or context_id is specified, it is an update,\n  otherwise it does an insertion.\n\n  It is not guaranteed that the created or updated executions, artifacts,\n  contexts and events will share the same `create_time_since_epoch`,\n  `last_update_time_since_epoch`, or `milliseconds_since_epoch` timestamps.\n\n  Args:\n    execution: The execution to be created or updated.\n    artifact_and_events: a pair of Artifact and Event that the execution uses\n      or generates. The event's execution id or artifact id can be empty, as\n      the artifact or execution may not be stored beforehand. If given, the\n      ids must match with the paired Artifact and the input execution.\n    contexts: The Contexts that the execution should be associated with and\n      the artifacts should be attributed to.\n    reuse_context_if_already_exist: When there's a race to publish executions\n      with a new context (no id) with the same context.name, by default there\n      will be one writer succeeds and the rest of the writers fail with\n      AlreadyExists errors. If set is to True, failed writers will reuse the\n      stored context.\n    reuse_artifact_if_already_exist_by_external_id: When there's a race to\n      publish executions with a new artifact with the same\n      artifact.external_id, by default there'll be one writer succeeds and the\n      rest of the writers returning AlreadyExists errors. If set to true and\n      an Artifact has non-empty external_id, the API will reuse the stored\n      artifact in the transaction and perform an update. Otherwise, it will\n      fall back to relying on `id` field to decide if it's update (if `id`\n      exists) or insert (if `id` is empty).\n    force_reuse_context: If True, for contexts with a context.id, the stored\n      context will NOT be updated. For such contexts,  we will only look at\n      the context.id to associate the context with the execution.\n    force_update_time: If it is true, `last_update_time_since_epoch` is\n      updated even if input execution is the same as stored execution.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    the execution id, the list of artifact's id, and the list of context's id.\n\n  Raises:\n    errors.InvalidArgumentError: If the id of the input nodes do not align\n      with the store. Please refer to InvalidArgument errors in other put\n      methods.\n    errors.AlreadyExistsError: If the new nodes to be created is already\n      exists. Please refer to AlreadyExists errors in other put methods.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutExecutionRequest(\n      execution=execution,\n      contexts=contexts,\n      options=metadata_store_service_pb2.PutExecutionRequest.Options(\n          reuse_context_if_already_exist=reuse_context_if_already_exist,\n          reuse_artifact_if_already_exist_by_external_id=(\n              reuse_artifact_if_already_exist_by_external_id\n          ),\n          force_reuse_context=force_reuse_context,\n          force_update_time=force_update_time,\n      ),\n  )\n  # Add artifact_and_event pairs to the request.\n  for pair in artifact_and_events:\n    if pair:\n      request.artifact_event_pairs.add(\n          artifact=pair[0], event=pair[1] if len(pair) == 2 else None)\n  response = metadata_store_service_pb2.PutExecutionResponse()\n  self._call('PutExecution', request, response)\n  artifact_ids = list(response.artifact_ids)\n  context_ids = list(response.context_ids)\n  return response.execution_id, artifact_ids, context_ids\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_execution_type","title":"put_execution_type","text":"<pre><code>put_execution_type(\n    execution_type: ExecutionType,\n    can_add_fields: bool = False,\n    can_omit_fields: bool = False,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; int\n</code></pre> <p>Inserts or updates an execution type.</p> <p>A type has a set of strong typed properties describing the schema of any stored instance associated with that type. A type is identified by a name and an optional version.</p> <p>Type Creation: If no type exists in the database with the given identifier (name, version), it creates a new type and returns the type_id.</p> <p>Type Evolution: If the request type with the same (name, version) already exists (let's call it stored_type), the method enforces the stored_type can be updated only when the request type is backward compatible for the already stored instances.</p> <p>Backwards compatibility is violated iff:</p> <ol> <li>there is a property where the request type and stored_type have      different value type (e.g., int vs. string)</li> <li><code>can_add_fields = false</code> and the request type has a new property that      is not stored.</li> <li><code>can_omit_fields = false</code> and stored_type has an existing property      that is not provided in the request type.</li> </ol> <p>If non-backward type change is required in the application, e.g., deprecate properties, re-purpose property name, change value types, a new type can be created with a different (name, version) identifier. Note the type version is optional, and a version value with empty string is treated as unset.</p> PARAMETER DESCRIPTION <code>execution_type</code> <p>the request type to be inserted or updated.</p> <p> TYPE: <code>ExecutionType</code> </p> <code>can_add_fields</code> <p>when true, new properties can be added; when false, returns ALREADY_EXISTS if the request type has properties that are not in stored_type.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>can_omit_fields</code> <p>when true, stored properties can be omitted in the request type; when false, returns ALREADY_EXISTS if the stored_type has properties not in the request type.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>the type_id of the response.</p> RAISES DESCRIPTION <code>AlreadyExistsError</code> <p>If the type is not backward compatible.</p> <code>InvalidArgumentError</code> <p>If the request type has no name, or any property value type is unknown.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_execution_type(\n    self,\n    execution_type: proto.ExecutionType,\n    can_add_fields: bool = False,\n    can_omit_fields: bool = False,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; int:\n  \"\"\"Inserts or updates an execution type.\n\n  A type has a set of strong typed properties describing the schema of any\n  stored instance associated with that type. A type is identified by a name\n  and an optional version.\n\n  Type Creation:\n  If no type exists in the database with the given identifier\n  (name, version), it creates a new type and returns the type_id.\n\n  Type Evolution:\n  If the request type with the same (name, version) already exists\n  (let's call it stored_type), the method enforces the stored_type can be\n  updated only when the request type is backward compatible for the already\n  stored instances.\n\n  Backwards compatibility is violated iff:\n\n    1. there is a property where the request type and stored_type have\n       different value type (e.g., int vs. string)\n    2. `can_add_fields = false` and the request type has a new property that\n       is not stored.\n    3. `can_omit_fields = false` and stored_type has an existing property\n       that is not provided in the request type.\n\n  If non-backward type change is required in the application, e.g.,\n  deprecate properties, re-purpose property name, change value types,\n  a new type can be created with a different (name, version) identifier.\n  Note the type version is optional, and a version value with empty string\n  is treated as unset.\n\n  Args:\n    execution_type: the request type to be inserted or updated.\n    can_add_fields: when true, new properties can be added; when false,\n      returns ALREADY_EXISTS if the request type has properties that are not\n      in stored_type.\n    can_omit_fields: when true, stored properties can be omitted in the\n      request type; when false, returns ALREADY_EXISTS if the stored_type has\n      properties not in the request type.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    the type_id of the response.\n\n  Raises:\n    errors.AlreadyExistsError: If the type is not backward compatible.\n    errors.InvalidArgumentError: If the request type has no name, or any\n      property value type is unknown.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutExecutionTypeRequest(\n      can_add_fields=can_add_fields,\n      can_omit_fields=can_omit_fields,\n      execution_type=execution_type)\n  response = metadata_store_service_pb2.PutExecutionTypeResponse()\n  self._call('PutExecutionType', request, response)\n  return response.type_id\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_executions","title":"put_executions","text":"<pre><code>put_executions(\n    executions: Sequence[Execution],\n    field_mask_paths: Optional[Sequence[str]] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[int]\n</code></pre> <p>Inserts or updates executions in the database.</p> <p>If an execution id is specified for an execution, it is an update. If an execution id is unspecified, it will insert a new execution. For new executions, type must be specified. For old executions, type must be unchanged or unspecified. When the name of an execution is given, it should be unique among executions of the same ExecutionType.</p> <p>It is not guaranteed that the created or updated executions will share the same <code>create_time_since_epoch</code> or <code>last_update_time_since_epoch</code> timestamps.</p> <p>If <code>field_mask_paths</code> is specified and non-empty:   1. while updating an existing execution, it only updates fields specified      in <code>field_mask_paths</code>.   2. while inserting a new execution, <code>field_mask_paths</code> will be ignored.   3. otherwise, <code>field_mask_paths</code> will be applied to all <code>executions</code>. If <code>field_mask_paths</code> is unspecified or is empty, it updates the execution as a whole.</p> PARAMETER DESCRIPTION <code>executions</code> <p>A list of executions to insert or update.</p> <p> TYPE: <code>Sequence[Execution]</code> </p> <code>field_mask_paths</code> <p>A list of field mask paths for masked update.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[int]</code> <p>A list of execution ids index-aligned with the input.</p> RAISES DESCRIPTION <code>AlreadyExistsError</code> <p>If execution's name is specified and it is already used by stored executions of that ExecutionType.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_executions(\n    self,\n    executions: Sequence[proto.Execution],\n    field_mask_paths: Optional[Sequence[str]] = None,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; List[int]:\n  \"\"\"Inserts or updates executions in the database.\n\n  If an execution id is specified for an execution, it is an update.\n  If an execution id is unspecified, it will insert a new execution.\n  For new executions, type must be specified.\n  For old executions, type must be unchanged or unspecified.\n  When the name of an execution is given, it should be unique among\n  executions of the same ExecutionType.\n\n  It is not guaranteed that the created or updated executions will share the\n  same `create_time_since_epoch` or `last_update_time_since_epoch` timestamps.\n\n  If `field_mask_paths` is specified and non-empty:\n    1. while updating an existing execution, it only updates fields specified\n       in `field_mask_paths`.\n    2. while inserting a new execution, `field_mask_paths` will be ignored.\n    3. otherwise, `field_mask_paths` will be applied to all `executions`.\n  If `field_mask_paths` is unspecified or is empty, it updates the execution\n  as a whole.\n\n  Args:\n    executions: A list of executions to insert or update.\n    field_mask_paths: A list of field mask paths for masked update.\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    A list of execution ids index-aligned with the input.\n\n  Raises:\n    errors.AlreadyExistsError: If execution's name is specified and it is\n      already used by stored executions of that ExecutionType.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutExecutionsRequest()\n  for x in executions:\n    request.executions.add().CopyFrom(x)\n\n  if field_mask_paths:\n    for path in field_mask_paths:\n      request.update_mask.paths.append(path)\n  response = metadata_store_service_pb2.PutExecutionsResponse()\n\n  self._call('PutExecutions', request, response)\n  return list(response.execution_ids)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_lineage_subgraph","title":"put_lineage_subgraph","text":"<pre><code>put_lineage_subgraph(\n    executions: Sequence[Execution],\n    artifacts: Sequence[Artifact],\n    contexts: Sequence[Context],\n    event_edges: Sequence[\n        Tuple[Optional[int], Optional[int], Event]\n    ],\n    reuse_context_if_already_exist: bool = False,\n    reuse_artifact_if_already_exist_by_external_id: bool = False,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Tuple[List[int], List[int], List[int]]\n</code></pre> <p>Inserts a collection of executions, artifacts, contexts, and events.</p> <p>This method atomically inserts or updates all specified executions, artifacts, and events and adds attributions and associations to related contexts.</p> <p>It is not guaranteed that the created or updated executions, artifacts, contexts and events will share the same <code>create_time_since_epoch</code>, <code>last_update_time_since_epoch</code>, or <code>milliseconds_since_epoch</code> timestamps.</p> PARAMETER DESCRIPTION <code>executions</code> <p>List of executions to be created or updated.</p> <p> TYPE: <code>Sequence[Execution]</code> </p> <code>artifacts</code> <p>List of artifacts to be created or updated.</p> <p> TYPE: <code>Sequence[Artifact]</code> </p> <code>contexts</code> <p>List of contexts to be created or reused. Contexts will be associated with the inserted executions and attributed to the inserted artifacts.</p> <p> TYPE: <code>Sequence[Context]</code> </p> <code>event_edges</code> <p>List of event edges in the subgraph to be inserted. Event edges are defined as an optional execution_index, an optional artifact_index, and a required event. Event edges must have an execution_index and/or an event.execution_id. Execution_index corresponds to an execution in the executions list at the specified index. If both execution_index and event.execution_id are provided, the execution ids of the execution and the event must match. The same rules apply to artifact_index and event.artifact_id.</p> <p> TYPE: <code>Sequence[Tuple[Optional[int], Optional[int], Event]]</code> </p> <code>reuse_context_if_already_exist</code> <p>When there's a race to publish executions with a new context (no id) with the same context.name, by default there will be one writer that succeeds and the rest of the writers will fail with AlreadyExists errors. If set to True, failed writers will reuse the stored context.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reuse_artifact_if_already_exist_by_external_id</code> <p>When there's a race to publish executions with a new artifact with the same artifact.external_id, by default there'll be one writer succeeds and the rest of the writers returning AlreadyExists errors. If set to true and an Artifact has non-empty external_id, the API will reuse the stored artifact in the transaction and perform an update. Otherwise, it will fall back to relying on <code>id</code> field to decide if it's update (if <code>id</code> exists) or insert (if <code>id</code> is empty).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[int]</code> <p>The lists of execution ids, artifact ids, and context ids index aligned</p> <code>List[int]</code> <p>to the input executions, artifacts, and contexts.</p> RAISES DESCRIPTION <code>InvalidArgumentError</code> <p>If the id of the input nodes do not align with the store. Please refer to InvalidArgument errors in other put methods.</p> <code>AlreadyExistsError</code> <p>If the new nodes to be created already exist. Please refer to AlreadyExists errors in other put methods.</p> <code>OutOfRangeError</code> <p>If event_edge indices do not correspond to existing indices in the input lists of executions and artifacts.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_lineage_subgraph(\n    self,\n    executions: Sequence[proto.Execution],\n    artifacts: Sequence[proto.Artifact],\n    contexts: Sequence[proto.Context],\n    event_edges: Sequence[Tuple[Optional[int], Optional[int], proto.Event]],\n    reuse_context_if_already_exist: bool = False,\n    reuse_artifact_if_already_exist_by_external_id: bool = False,\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; Tuple[List[int], List[int], List[int]]:\n  \"\"\"Inserts a collection of executions, artifacts, contexts, and events.\n\n  This method atomically inserts or updates all specified executions,\n  artifacts, and events and adds attributions and associations to related\n  contexts.\n\n  It is not guaranteed that the created or updated executions, artifacts,\n  contexts and events will share the same `create_time_since_epoch`,\n  `last_update_time_since_epoch`, or `milliseconds_since_epoch` timestamps.\n\n  Args:\n    executions: List of executions to be created or updated.\n    artifacts: List of artifacts to be created or updated.\n    contexts: List of contexts to be created or reused. Contexts will be\n      associated with the inserted executions and attributed to the inserted\n      artifacts.\n    event_edges: List of event edges in the subgraph to be inserted. Event\n      edges are defined as an optional execution_index, an optional\n      artifact_index, and a required event. Event edges must have an\n      execution_index and/or an event.execution_id. Execution_index\n      corresponds to an execution in the executions list at the specified\n      index. If both execution_index and event.execution_id are provided, the\n      execution ids of the execution and the event must match. The same rules\n      apply to artifact_index and event.artifact_id.\n    reuse_context_if_already_exist: When there's a race to publish executions\n      with a new context (no id) with the same context.name, by default there\n      will be one writer that succeeds and the rest of the writers will fail\n      with AlreadyExists errors. If set to True, failed writers will reuse the\n      stored context.\n    reuse_artifact_if_already_exist_by_external_id: When there's a race to\n      publish executions with a new artifact with the same\n      artifact.external_id, by default there'll be one writer succeeds and the\n      rest of the writers returning AlreadyExists errors. If set to true and\n      an Artifact has non-empty external_id, the API will reuse the stored\n      artifact in the transaction and perform an update. Otherwise, it will\n      fall back to relying on `id` field to decide if it's update (if `id`\n      exists) or insert (if `id` is empty).\n    extra_options: ExtraOptions instance.\n\n  Returns:\n    The lists of execution ids, artifact ids, and context ids index aligned\n    to the input executions, artifacts, and contexts.\n\n  Raises:\n    errors.InvalidArgumentError: If the id of the input nodes do not align\n      with the store. Please refer to InvalidArgument errors in other put\n      methods.\n    errors.AlreadyExistsError: If the new nodes to be created already exist.\n      Please refer to AlreadyExists errors in other put methods.\n    errors.OutOfRangeError: If event_edge indices do not correspond to\n      existing indices in the input lists of executions and artifacts.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutLineageSubgraphRequest(\n      executions=executions,\n      artifacts=artifacts,\n      contexts=contexts,\n      options=metadata_store_service_pb2.PutLineageSubgraphRequest.Options(\n          reuse_context_if_already_exist=reuse_context_if_already_exist,\n          reuse_artifact_if_already_exist_by_external_id=(\n              reuse_artifact_if_already_exist_by_external_id)))\n\n  # Add event edges to the request\n  for execution_index, artifact_index, event in event_edges:\n    request.event_edges.add(\n        execution_index=execution_index,\n        artifact_index=artifact_index,\n        event=event)\n\n  response = metadata_store_service_pb2.PutLineageSubgraphResponse()\n  self._call('PutLineageSubgraph', request, response)\n  execution_ids = list(response.execution_ids)\n  artifact_ids = list(response.artifact_ids)\n  context_ids = list(response.context_ids)\n  return execution_ids, artifact_ids, context_ids\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.MetadataStore.put_parent_contexts","title":"put_parent_contexts","text":"<pre><code>put_parent_contexts(\n    parent_contexts: Sequence[ParentContext],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; None\n</code></pre> <p>Inserts parent contexts in the database.</p> <p>The <code>child_id</code> and <code>parent_id</code> in every parent context must already exist.</p> PARAMETER DESCRIPTION <code>parent_contexts</code> <p>A list of parent contexts to insert.</p> <p> TYPE: <code>Sequence[ParentContext]</code> </p> <code>extra_options</code> <p>ExtraOptions instance.</p> <p> TYPE: <code>Optional[ExtraOptions]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>InvalidArgumentError</code> <p>if no context matches the <code>child_id</code> or no context matches the <code>parent_id</code> in any parent context.</p> <code>AlreadyExistsError</code> <p>if the same parent context already exists.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def put_parent_contexts(\n    self,\n    parent_contexts: Sequence[proto.ParentContext],\n    extra_options: Optional[ExtraOptions] = None,\n) -&gt; None:\n  \"\"\"Inserts parent contexts in the database.\n\n  The `child_id` and `parent_id` in every parent context must already exist.\n\n  Args:\n    parent_contexts: A list of parent contexts to insert.\n    extra_options: ExtraOptions instance.\n\n  Raises:\n    errors.InvalidArgumentError: if no context matches the `child_id` or no\n      context matches the `parent_id` in any parent context.\n    errors.AlreadyExistsError: if the same parent context already exists.\n  \"\"\"\n  del extra_options\n  request = metadata_store_service_pb2.PutParentContextsRequest()\n  for x in parent_contexts:\n    request.parent_contexts.add().CopyFrom(x)\n  response = metadata_store_service_pb2.PutParentContextsResponse()\n  self._call('PutParentContexts', request, response)\n</code></pre>"},{"location":"api/mlmd/mlmd/#ml_metadata.OrderByField","title":"OrderByField","text":"<p>               Bases: <code>Enum</code></p> <p>Defines the available fields to order results in ListOperations.</p> ATTRIBUTE DESCRIPTION <code>CREATE_TIME</code> <p><code>&lt;OrderByField.CREATE_TIME: 1&gt;</code></p> <p> </p> <code>ID</code> <p><code>&lt;OrderByField.ID: 3&gt;</code></p> <p> </p> <code>UPDATE_TIME</code> <p><code>&lt;OrderByField.UPDATE_TIME: 2&gt;</code></p> <p> </p>"},{"location":"api/mlmd/mlmd/#ml_metadata-functions","title":"Functions","text":""},{"location":"api/mlmd/mlmd/#ml_metadata.downgrade_schema","title":"downgrade_schema","text":"<pre><code>downgrade_schema(\n    config: ConnectionConfig,\n    downgrade_to_schema_version: int,\n) -&gt; None\n</code></pre> <p>Downgrades the db specified in the connection config to a schema version.</p> <p>If <code>downgrade_to_schema_version</code> is greater or equals to zero and less than the current library's schema version, it runs a downgrade transaction to revert the db schema and migrate the data. The update is transactional, and any failure will cause a full rollback of the downgrade. Once the downgrade is done, the user needs to use the older version of the library to connect to the database.</p> PARAMETER DESCRIPTION <code>config</code> <p>a <code>proto.ConnectionConfig</code> having the connection params.</p> <p> TYPE: <code>ConnectionConfig</code> </p> <code>downgrade_to_schema_version</code> <p>downgrades the given database to a specific version. For v0.13.2 release, the schema_version is 0. For 0.14.0 and 0.15.0 release, the schema_version is 4. More details are described in g3doc/get_start.md#upgrade-mlmd-library</p> <p> TYPE: <code>int</code> </p> RAISES DESCRIPTION <code>InvalidArgumentError</code> <p>if the <code>downgrade_to_schema_version</code> is not given or it is negative or greater than the library version.</p> <code>RuntimeError</code> <p>if the downgrade is not finished, return detailed error.</p> Source code in <code>ml_metadata/metadata_store/metadata_store.py</code> <pre><code>def downgrade_schema(\n    config: proto.ConnectionConfig, downgrade_to_schema_version: int\n) -&gt; None:\n  \"\"\"Downgrades the db specified in the connection config to a schema version.\n\n  If `downgrade_to_schema_version` is greater or equals to zero and less than\n  the current library's schema version, it runs a downgrade transaction to\n  revert the db schema and migrate the data. The update is transactional, and\n  any failure will cause a full rollback of the downgrade. Once the downgrade\n  is done, the user needs to use the older version of the library to connect to\n  the database.\n\n  Args:\n    config: a `proto.ConnectionConfig` having the connection params.\n    downgrade_to_schema_version: downgrades the given database to a specific\n      version. For v0.13.2 release, the schema_version is 0. For 0.14.0 and\n      0.15.0 release, the schema_version is 4. More details are described in\n      g3doc/get_start.md#upgrade-mlmd-library\n\n  Raises:\n    errors.InvalidArgumentError: if the `downgrade_to_schema_version` is not\n      given or it is negative or greater than the library version.\n    RuntimeError: if the downgrade is not finished, return detailed error.\n  \"\"\"\n  if downgrade_to_schema_version &lt; 0:\n    raise errors.make_exception(\n        'downgrade_to_schema_version not specified', errors.INVALID_ARGUMENT\n    )\n\n  try:\n    migration_options = metadata_store_pb2.MigrationOptions()\n    migration_options.downgrade_to_schema_version = downgrade_to_schema_version\n    metadata_store_serialized.CreateMetadataStore(\n        config.SerializeToString(), migration_options.SerializeToString())\n  except RuntimeError as e:\n    if str(e).startswith('MLMD cannot be downgraded to schema_version'):\n      raise errors.make_exception(str(e), errors.INVALID_ARGUMENT) from e\n    if not str(e).startswith('Downgrade migration was performed.'):\n      raise e\n    # downgrade is done.\n    logging.log(logging.INFO, str(e))\n</code></pre>"},{"location":"api/mlmd.errors/","title":"mlmd.errors","text":"<p>Exception types for MLMD errors.</p>"},{"location":"api/mlmd.errors/#classes","title":"Classes","text":"<p><code>class AbortedError</code>: The operation was aborted, typically due to a concurrent action.</p> <p><code>class AlreadyExistsError</code>: Raised when an entity that we attempted to create already exists.</p> <p><code>class CancelledError</code>: Raised when an operation or step is cancelled.</p> <p><code>class DataLossError</code>: Raised when unrecoverable data loss or corruption is encountered.</p> <p><code>class DeadlineExceededError</code>: Raised when a deadline expires before an operation could complete.</p> <p><code>class FailedPreconditionError</code>: Raised when the system is not in a state to execute an operation.</p> <p><code>class InternalError</code>: Raised when the system experiences an internal error.</p> <p><code>class InvalidArgumentError</code>: Raised when an operation receives an invalid argument.</p> <p><code>class NotFoundError</code>: Raised when a requested entity was not found.</p> <p><code>class OutOfRangeError</code>: Raised when an operation iterates past the valid input range.</p> <p><code>class PermissionDeniedError</code>: Raised when the caller does not have permission to run an operation.</p> <p><code>class ResourceExhaustedError</code>: Some resource has been exhausted.</p> <p><code>class StatusError</code>: A general error class that cast maps Status to typed errors.</p> <p><code>class UnauthenticatedError</code>: The request does not have valid authentication credentials.</p> <p><code>class UnavailableError</code>: Raised when the runtime is currently unavailable.</p> <p><code>class UnimplementedError</code>: Raised when an operation has not been implemented.</p> <p><code>class UnknownError</code>: Raised when an operation failed reason is unknown.</p>"},{"location":"api/mlmd.errors/#functions","title":"Functions","text":"<p><code>exception_type_from_error_code(...)</code>: Returns error class w.r.t. the error_code.</p> <p><code>make_exception(...)</code>: Makes an exception with the MLMD error code.</p>"},{"location":"api/mlmd.errors/mlmd.errors/","title":"mlmd.errors","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors","title":"ml_metadata.errors","text":"<p>Exception types for MLMD errors.</p>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.ABORTED","title":"ABORTED  <code>module-attribute</code>","text":"<pre><code>ABORTED = 10\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.ALREADY_EXISTS","title":"ALREADY_EXISTS  <code>module-attribute</code>","text":"<pre><code>ALREADY_EXISTS = 6\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.CANCELLED","title":"CANCELLED  <code>module-attribute</code>","text":"<pre><code>CANCELLED = 1\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DATA_LOSS","title":"DATA_LOSS  <code>module-attribute</code>","text":"<pre><code>DATA_LOSS = 15\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DEADLINE_EXCEEDED","title":"DEADLINE_EXCEEDED  <code>module-attribute</code>","text":"<pre><code>DEADLINE_EXCEEDED = 4\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.FAILED_PRECONDITION","title":"FAILED_PRECONDITION  <code>module-attribute</code>","text":"<pre><code>FAILED_PRECONDITION = 9\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.INTERNAL","title":"INTERNAL  <code>module-attribute</code>","text":"<pre><code>INTERNAL = 13\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.INVALID_ARGUMENT","title":"INVALID_ARGUMENT  <code>module-attribute</code>","text":"<pre><code>INVALID_ARGUMENT = 3\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.NOT_FOUND","title":"NOT_FOUND  <code>module-attribute</code>","text":"<pre><code>NOT_FOUND = 5\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.OK","title":"OK  <code>module-attribute</code>","text":"<pre><code>OK = 0\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.OUT_OF_RANGE","title":"OUT_OF_RANGE  <code>module-attribute</code>","text":"<pre><code>OUT_OF_RANGE = 11\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.PERMISSION_DENIED","title":"PERMISSION_DENIED  <code>module-attribute</code>","text":"<pre><code>PERMISSION_DENIED = 7\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.RESOURCE_EXHAUSTED","title":"RESOURCE_EXHAUSTED  <code>module-attribute</code>","text":"<pre><code>RESOURCE_EXHAUSTED = 8\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UNAUTHENTICATED","title":"UNAUTHENTICATED  <code>module-attribute</code>","text":"<pre><code>UNAUTHENTICATED = 16\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UNAVAILABLE","title":"UNAVAILABLE  <code>module-attribute</code>","text":"<pre><code>UNAVAILABLE = 14\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UNIMPLEMENTED","title":"UNIMPLEMENTED  <code>module-attribute</code>","text":"<pre><code>UNIMPLEMENTED = 12\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UNKNOWN","title":"UNKNOWN  <code>module-attribute</code>","text":"<pre><code>UNKNOWN = 2\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors-classes","title":"Classes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.AbortedError","title":"AbortedError","text":"<pre><code>AbortedError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>The operation was aborted, typically due to a concurrent action.</p> <p>Creates an <code>AbortedError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates an `AbortedError`.\"\"\"\n  super(AbortedError, self).__init__(message, ABORTED)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.AbortedError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.AbortedError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.AbortedError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.AbortedError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.AlreadyExistsError","title":"AlreadyExistsError","text":"<pre><code>AlreadyExistsError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when an entity that we attempted to create already exists.</p> <p>Creates an <code>AlreadyExistsError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates an `AlreadyExistsError`.\"\"\"\n  super(AlreadyExistsError, self).__init__(message, ALREADY_EXISTS)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.AlreadyExistsError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.AlreadyExistsError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.AlreadyExistsError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.AlreadyExistsError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.CancelledError","title":"CancelledError","text":"<pre><code>CancelledError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when an operation or step is cancelled.</p> <p>Creates a <code>CancelledError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates a `CancelledError`.\"\"\"\n  super(CancelledError, self).__init__(message, CANCELLED)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.CancelledError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.CancelledError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.CancelledError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.CancelledError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DataLossError","title":"DataLossError","text":"<pre><code>DataLossError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when unrecoverable data loss or corruption is encountered.</p> <p>Creates a <code>DataLossError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates a `DataLossError`.\"\"\"\n  super(DataLossError, self).__init__(message, DATA_LOSS)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DataLossError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DataLossError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DataLossError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DataLossError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DeadlineExceededError","title":"DeadlineExceededError","text":"<pre><code>DeadlineExceededError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when a deadline expires before an operation could complete.</p> <p>Creates a <code>DeadlineExceededError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates a `DeadlineExceededError`.\"\"\"\n  super(DeadlineExceededError, self).__init__(message, DEADLINE_EXCEEDED)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DeadlineExceededError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DeadlineExceededError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DeadlineExceededError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.DeadlineExceededError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.FailedPreconditionError","title":"FailedPreconditionError","text":"<pre><code>FailedPreconditionError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when the system is not in a state to execute an operation.</p> <p>Creates a <code>FailedPreconditionError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates a `FailedPreconditionError`.\"\"\"\n  super(FailedPreconditionError, self).__init__(message, FAILED_PRECONDITION)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.FailedPreconditionError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.FailedPreconditionError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.FailedPreconditionError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.FailedPreconditionError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.InternalError","title":"InternalError","text":"<pre><code>InternalError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when the system experiences an internal error.</p> <p>Creates an <code>InternalError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates an `InternalError`.\"\"\"\n  super(InternalError, self).__init__(message, INTERNAL)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.InternalError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.InternalError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.InternalError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.InternalError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.InvalidArgumentError","title":"InvalidArgumentError","text":"<pre><code>InvalidArgumentError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when an operation receives an invalid argument.</p> <p>Creates an <code>InvalidArgumentError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates an `InvalidArgumentError`.\"\"\"\n  super(InvalidArgumentError, self).__init__(message, INVALID_ARGUMENT)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.InvalidArgumentError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.InvalidArgumentError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.InvalidArgumentError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.InvalidArgumentError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.NotFoundError","title":"NotFoundError","text":"<pre><code>NotFoundError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when a requested entity was not found.</p> <p>Creates a <code>NotFoundError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates a `NotFoundError`.\"\"\"\n  super(NotFoundError, self).__init__(message, NOT_FOUND)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.NotFoundError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.NotFoundError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.NotFoundError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.NotFoundError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.OutOfRangeError","title":"OutOfRangeError","text":"<pre><code>OutOfRangeError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when an operation iterates past the valid input range.</p> <p>Creates an <code>OutOfRangeError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates an `OutOfRangeError`.\"\"\"\n  super(OutOfRangeError, self).__init__(message, OUT_OF_RANGE)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.OutOfRangeError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.OutOfRangeError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.OutOfRangeError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.OutOfRangeError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.PermissionDeniedError","title":"PermissionDeniedError","text":"<pre><code>PermissionDeniedError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when the caller does not have permission to run an operation.</p> <p>Creates a <code>PermissionDeniedError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates a `PermissionDeniedError`.\"\"\"\n  super(PermissionDeniedError, self).__init__(message, PERMISSION_DENIED)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.PermissionDeniedError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.PermissionDeniedError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.PermissionDeniedError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.PermissionDeniedError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.ResourceExhaustedError","title":"ResourceExhaustedError","text":"<pre><code>ResourceExhaustedError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Some resource has been exhausted.</p> <p>Creates a <code>ResourceExhaustedError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates a `ResourceExhaustedError`.\"\"\"\n  super(ResourceExhaustedError, self).__init__(message, RESOURCE_EXHAUSTED)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.ResourceExhaustedError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.ResourceExhaustedError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.ResourceExhaustedError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.ResourceExhaustedError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.StatusError","title":"StatusError","text":"<pre><code>StatusError(message, error_code)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>A general error class that cast maps Status to typed errors.</p> <p>Creates a <code>StatusError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message, error_code):\n  \"\"\"Creates a `StatusError`.\"\"\"\n  super(StatusError, self).__init__(message)\n  self.message = message\n  self.error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.StatusError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.StatusError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.StatusError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.StatusError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnauthenticatedError","title":"UnauthenticatedError","text":"<pre><code>UnauthenticatedError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>The request does not have valid authentication credentials.</p> <p>Creates an <code>UnauthenticatedError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates an `UnauthenticatedError`.\"\"\"\n  super(UnauthenticatedError, self).__init__(message, UNAUTHENTICATED)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnauthenticatedError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnauthenticatedError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnauthenticatedError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnauthenticatedError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnavailableError","title":"UnavailableError","text":"<pre><code>UnavailableError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when the runtime is currently unavailable.</p> <p>Creates an <code>UnavailableError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates an `UnavailableError`.\"\"\"\n  super(UnavailableError, self).__init__(message, UNAVAILABLE)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnavailableError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnavailableError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnavailableError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnavailableError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnimplementedError","title":"UnimplementedError","text":"<pre><code>UnimplementedError(message)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when an operation has not been implemented.</p> <p>Creates an <code>UnimplementedError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message):\n  \"\"\"Creates an `UnimplementedError`.\"\"\"\n  super(UnimplementedError, self).__init__(message, UNIMPLEMENTED)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnimplementedError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnimplementedError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnimplementedError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnimplementedError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnknownError","title":"UnknownError","text":"<pre><code>UnknownError(message, error_code=UNKNOWN)\n</code></pre> <p>               Bases: <code>StatusError</code></p> <p>Raised when an operation failed reason is unknown.</p> <p>Creates an <code>UnknownError</code>.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def __init__(self, message, error_code=UNKNOWN):\n  \"\"\"Creates an `UnknownError`.\"\"\"\n  super(UnknownError, self).__init__(message, error_code)\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnknownError-attributes","title":"Attributes","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnknownError.error_code","title":"error_code  <code>instance-attribute</code>","text":"<pre><code>error_code = error_code\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnknownError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.UnknownError-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors-functions","title":"Functions","text":""},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.exception_type_from_error_code","title":"exception_type_from_error_code","text":"<pre><code>exception_type_from_error_code(error_code)\n</code></pre> <p>Returns error class w.r.t. the error_code.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def exception_type_from_error_code(error_code):\n  \"\"\"Returns error class w.r.t. the error_code.\"\"\"\n  return _CODE_TO_EXCEPTION_CLASS[error_code]\n</code></pre>"},{"location":"api/mlmd.errors/mlmd.errors/#ml_metadata.errors.make_exception","title":"make_exception","text":"<pre><code>make_exception(message: str, error_code: int)\n</code></pre> <p>Makes an exception with the MLMD error code.</p> PARAMETER DESCRIPTION <code>message</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>error_code</code> <p>MLMD error code.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <p>An exception.</p> Source code in <code>ml_metadata/errors.py</code> <pre><code>def make_exception(message: str, error_code: int):\n  \"\"\"Makes an exception with the MLMD error code.\n\n  Args:\n    message: Error message.\n    error_code: MLMD error code.\n\n  Returns:\n    An exception.\n  \"\"\"\n\n  try:\n    exc_type = exception_type_from_error_code(error_code)\n    # log internal backend engine errors only.\n    if error_code == INTERNAL:\n      logging.log(\n          logging.WARNING, 'mlmd client %s: %s', exc_type.__name__, message\n      )\n    return exc_type(message)\n  except KeyError:\n    return UnknownError(message)\n</code></pre>"},{"location":"api/mlmd.proto/","title":"mlmd.proto","text":"<p>ML Metadata proto module.</p>"},{"location":"api/mlmd.proto/#classes","title":"Classes","text":"<p><code>class Artifact</code>: An artifact represents an input or an output of individual steps in a ML workflow, e.g., a trained model, an input dataset, and evaluation metrics.</p> <p><code>class ArtifactType</code>: A user defined type about a collection of artifacts and their properties that are stored in the metadata store.</p> <p><code>class Association</code>: An association represents the relationship between executions and contexts.</p> <p><code>class Attribution</code>: An attribution represents the relationship between artifacts and contexts.</p> <p><code>class ConnectionConfig</code>: A connection configuration specifying the persistent backend to be used with MLMD.</p> <p><code>class Context</code>: A context defines a group of artifacts and/or executions.</p> <p><code>class ContextType</code>: A user defined type about a collection of contexts and their properties that are stored in the metadata store.</p> <p><code>class Event</code>: An event records the relationship between artifacts and executions.</p> <p><code>class Execution</code>: An execution describes a component run or a step in an ML workflow along with its runtime parameters, e.g., a Trainer run, a data transformation step.</p> <p><code>class ExecutionType</code>: A user defined type about a collection of executions and their properties that are stored in the metadata store.</p> <p><code>class FakeDatabaseConfig</code>: An in-memory database configuration for testing purpose.</p> <p><code>class MetadataStoreClientConfig</code>: A connection configuration to use a MLMD server as the persistent backend.</p> <p><code>class MySQLDatabaseConfig</code>: A connection configuration to use a MySQL db instance as a MLMD backend.</p> <p><code>class ParentContext</code>: A parental context represents the relationship between contexts.</p> <p><code>class SqliteMetadataSourceConfig</code>: A connection configuration to use a Sqlite db file as a MLMD backend.</p>"},{"location":"api/mlmd.proto/mlmd.proto/","title":"mlmd.proto","text":""},{"location":"api/mlmd.proto/mlmd.proto/#ml_metadata.proto","title":"ml_metadata.proto","text":"<p>ML Metadata proto module.</p>"}]}